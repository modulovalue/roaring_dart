// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_element, unused_field
import 'dart:ffi' as ffi;

/// Bindings to RoaringBitmaps.
class DartRoaringBitmaps {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  DartRoaringBitmaps(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  DartRoaringBitmaps.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> signal(
    int arg0,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> arg1,
  ) {
    return _signal(
      arg0,
      arg1,
    );
  }

  late final _signalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
              ffi.Int,
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>>('signal');
  late final _signal = _signalPtr.asFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
          int, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>();

  int getpriority(
    int arg0,
    int arg1,
  ) {
    return _getpriority(
      arg0,
      arg1,
    );
  }

  late final _getpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t)>>(
          'getpriority');
  late final _getpriority =
      _getpriorityPtr.asFunction<int Function(int, int)>();

  int getiopolicy_np(
    int arg0,
    int arg1,
  ) {
    return _getiopolicy_np(
      arg0,
      arg1,
    );
  }

  late final _getiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'getiopolicy_np');
  late final _getiopolicy_np =
      _getiopolicy_npPtr.asFunction<int Function(int, int)>();

  int getrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _getrlimit(
      arg0,
      arg1,
    );
  }

  late final _getrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'getrlimit');
  late final _getrlimit =
      _getrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int getrusage(
    int arg0,
    ffi.Pointer<rusage> arg1,
  ) {
    return _getrusage(
      arg0,
      arg1,
    );
  }

  late final _getrusagePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rusage>)>>(
      'getrusage');
  late final _getrusage =
      _getrusagePtr.asFunction<int Function(int, ffi.Pointer<rusage>)>();

  int setpriority(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setpriority(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t, ffi.Int)>>(
          'setpriority');
  late final _setpriority =
      _setpriorityPtr.asFunction<int Function(int, int, int)>();

  int setiopolicy_np(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setiopolicy_np(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'setiopolicy_np');
  late final _setiopolicy_np =
      _setiopolicy_npPtr.asFunction<int Function(int, int, int)>();

  int setrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _setrlimit(
      arg0,
      arg1,
    );
  }

  late final _setrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'setrlimit');
  late final _setrlimit =
      _setrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int wait(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return _wait(
      arg0,
    );
  }

  late final _waitPtr =
      _lookup<ffi.NativeFunction<pid_t Function(ffi.Pointer<ffi.Int>)>>('wait');
  late final _wait = _waitPtr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int waitpid(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
  ) {
    return _waitpid(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _waitpidPtr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int)>>('waitpid');
  late final _waitpid =
      _waitpidPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int>, int)>();

  int waitid(
    int arg0,
    int arg1,
    ffi.Pointer<siginfo_t> arg2,
    int arg3,
  ) {
    return _waitid(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _waitidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int32, id_t, ffi.Pointer<siginfo_t>, ffi.Int)>>('waitid');
  late final _waitid = _waitidPtr
      .asFunction<int Function(int, int, ffi.Pointer<siginfo_t>, int)>();

  late final ffi.Pointer<ffi.Int> ___mb_cur_max =
      _lookup<ffi.Int>('__mb_cur_max');

  int get __mb_cur_max => ___mb_cur_max.value;

  set __mb_cur_max(int value) => ___mb_cur_max.value = value;

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'malloc');
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(
    int __count,
    int __size,
  ) {
    return _calloc(
      __count,
      __size,
    );
  }

  late final _callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void free(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _free(
      arg0,
    );
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free');
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('realloc');
  late final _realloc = _reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size)>>('posix_memalign');
  late final _posix_memalign = _posix_memalignPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int abs(
    int arg0,
  ) {
    return _abs(
      arg0,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
  ) {
    return _atexit(
      arg0,
    );
  }

  late final _atexitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>('atexit');
  late final _atexit = _atexitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  double atof(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atof(
      arg0,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoi(
      arg0,
    );
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'atoi');
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atol(
      arg0,
    );
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'atol');
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoll(
      arg0,
    );
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
          'atoll');
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _bsearchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('bsearch');
  late final _bsearch = _bsearchPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  div_t div(
    int arg0,
    int arg1,
  ) {
    return _div(
      arg0,
      arg1,
    );
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  void exit(
    int arg0,
  ) {
    return _exit(
      arg0,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('exit');
  late final _exit = _exitPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> getenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getenv(
      arg0,
    );
  }

  late final _getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getenv');
  late final _getenv = _getenvPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int labs(
    int arg0,
  ) {
    return _labs(
      arg0,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  ldiv_t ldiv(
    int arg0,
    int arg1,
  ) {
    return _ldiv(
      arg0,
      arg1,
    );
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  int llabs(
    int arg0,
  ) {
    return _llabs(
      arg0,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  lldiv_t lldiv(
    int arg0,
    int arg1,
  ) {
    return _lldiv(
      arg0,
      arg1,
    );
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
          'lldiv');
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  int mblen(
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _mbstowcs(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mbstowcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbstowcs');
  late final _mbstowcs = _mbstowcsPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int mbtowc(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _mbtowc(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mbtowcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbtowc');
  late final _mbtowc = _mbtowcPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort');
  late final _qsort = _qsortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  void srand(
    int arg0,
  ) {
    return _srand(
      arg0,
    );
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  double strtod(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtod(
      arg0,
      arg1,
    );
  }

  late final _strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtod');
  late final _strtod = _strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double strtof(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtof(
      arg0,
      arg1,
    );
  }

  late final _strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtof');
  late final _strtof = _strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtol(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtol');
  late final _strtol = _strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoll(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtollPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoll');
  late final _strtoll = _strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoul(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoul');
  late final _strtoul = _strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoull(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoull');
  late final _strtoull = _strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int system(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _system(
      arg0,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.WChar> arg1,
    int arg2,
  ) {
    return _wcstombs(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wcstombsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcstombs');
  late final _wcstombs = _wcstombsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)>();

  int wctomb(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _wctomb(
      arg0,
      arg1,
    );
  }

  late final _wctombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>>('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  void _Exit(
    int arg0,
  ) {
    return __Exit(
      arg0,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  int a64l(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _a64l(
      arg0,
    );
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'a64l');
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('drand48');
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  ffi.Pointer<ffi.Char> ecvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _ecvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _ecvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('ecvt');
  late final _ecvt = _ecvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  double erand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _erand48(
      arg0,
    );
  }

  late final _erand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>>('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _fcvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _fcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('fcvt');
  late final _fcvt = _fcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> gcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _gcvt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _gcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>>('gcvt');
  late final _gcvt = _gcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _getsubopt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int grantpt(
    int arg0,
  ) {
    return _grantpt(
      arg0,
    );
  }

  late final _grantptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('grantpt');
  late final _grantpt = _grantptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _initstate(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _initstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size)>>('initstate');
  late final _initstate = _initstatePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int jrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _jrand48(
      arg0,
    );
  }

  late final _jrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> l64a(
    int arg0,
  ) {
    return _l64a(
      arg0,
    );
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
          'l64a');
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  void lcong48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _lcong48(
      arg0,
    );
  }

  late final _lcong48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>>('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('lrand48');
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mktemp(
      arg0,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mkstemp(
      arg0,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('mrand48');
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int nrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _nrand48(
      arg0,
    );
  }

  late final _nrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int posix_openpt(
    int arg0,
  ) {
    return _posix_openpt(
      arg0,
    );
  }

  late final _posix_openptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('posix_openpt');
  late final _posix_openpt = _posix_openptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> ptsname(
    int arg0,
  ) {
    return _ptsname(
      arg0,
    );
  }

  late final _ptsnamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'ptsname');
  late final _ptsname =
      _ptsnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int putenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _putenv(
      arg0,
    );
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'putenv');
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int random() {
    return _random();
  }

  late final _randomPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('random');
  late final _random = _randomPtr.asFunction<int Function()>();

  int rand_r(
    ffi.Pointer<ffi.UnsignedInt> arg0,
  ) {
    return _rand_r(
      arg0,
    );
  }

  late final _rand_rPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>>(
      'rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _realpath(
      arg0,
      arg1,
    );
  }

  late final _realpathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('realpath');
  late final _realpath = _realpathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.UnsignedShort> seed48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _seed48(
      arg0,
    );
  }

  late final _seed48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>)>>('seed48');
  late final _seed48 = _seed48Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          ffi.Pointer<ffi.UnsignedShort>)>();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __overwrite,
  ) {
    return _setenv(
      __name,
      __value,
      __overwrite,
    );
  }

  late final _setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('setenv');
  late final _setenv = _setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void setkey(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setkey(
      arg0,
    );
  }

  late final _setkeyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setkey');
  late final _setkey =
      _setkeyPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> setstate(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setstate(
      arg0,
    );
  }

  late final _setstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('setstate');
  late final _setstate = _setstatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void srand48(
    int arg0,
  ) {
    return _srand48(
      arg0,
    );
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  void srandom(
    int arg0,
  ) {
    return _srandom(
      arg0,
    );
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'srandom');
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  int unlockpt(
    int arg0,
  ) {
    return _unlockpt(
      arg0,
    );
  }

  late final _unlockptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('unlockpt');
  late final _unlockpt = _unlockptPtr.asFunction<int Function(int)>();

  int unsetenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _unsetenv(
      arg0,
    );
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unsetenv');
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  void atomic_thread_fence(
    int arg0,
  ) {
    return _atomic_thread_fence(
      arg0,
    );
  }

  late final _atomic_thread_fencePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'atomic_thread_fence');
  late final _atomic_thread_fence =
      _atomic_thread_fencePtr.asFunction<void Function(int)>();

  void atomic_signal_fence(
    int arg0,
  ) {
    return _atomic_signal_fence(
      arg0,
    );
  }

  late final _atomic_signal_fencePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'atomic_signal_fence');
  late final _atomic_signal_fence =
      _atomic_signal_fencePtr.asFunction<void Function(int)>();

  bool atomic_flag_test_and_set(
    ffi.Pointer<atomic_flag> arg0,
  ) {
    return _atomic_flag_test_and_set(
      arg0,
    );
  }

  late final _atomic_flag_test_and_setPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<atomic_flag>)>>(
          'atomic_flag_test_and_set');
  late final _atomic_flag_test_and_set = _atomic_flag_test_and_setPtr
      .asFunction<bool Function(ffi.Pointer<atomic_flag>)>();

  bool atomic_flag_test_and_set_explicit(
    ffi.Pointer<atomic_flag> arg0,
    int arg1,
  ) {
    return _atomic_flag_test_and_set_explicit(
      arg0,
      arg1,
    );
  }

  late final _atomic_flag_test_and_set_explicitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<atomic_flag>,
              ffi.Int32)>>('atomic_flag_test_and_set_explicit');
  late final _atomic_flag_test_and_set_explicit =
      _atomic_flag_test_and_set_explicitPtr
          .asFunction<bool Function(ffi.Pointer<atomic_flag>, int)>();

  void atomic_flag_clear(
    ffi.Pointer<atomic_flag> arg0,
  ) {
    return _atomic_flag_clear(
      arg0,
    );
  }

  late final _atomic_flag_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<atomic_flag>)>>(
          'atomic_flag_clear');
  late final _atomic_flag_clear = _atomic_flag_clearPtr
      .asFunction<void Function(ffi.Pointer<atomic_flag>)>();

  void atomic_flag_clear_explicit(
    ffi.Pointer<atomic_flag> arg0,
    int arg1,
  ) {
    return _atomic_flag_clear_explicit(
      arg0,
      arg1,
    );
  }

  late final _atomic_flag_clear_explicitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<atomic_flag>,
              ffi.Int32)>>('atomic_flag_clear_explicit');
  late final _atomic_flag_clear_explicit = _atomic_flag_clear_explicitPtr
      .asFunction<void Function(ffi.Pointer<atomic_flag>, int)>();

  int renameat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
  ) {
    return _renameat(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _renameatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('renameat');
  late final _renameat = _renameatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int renamex_np(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _renamex_np(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _renamex_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('renamex_np');
  late final _renamex_np = _renamex_npPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int renameatx_np(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
    int arg4,
  ) {
    return _renameatx_np(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _renameatx_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('renameatx_np');
  late final _renameatx_np = _renameatx_npPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stdinp =
      _lookup<ffi.Pointer<FILE>>('__stdinp');

  ffi.Pointer<FILE> get __stdinp => ___stdinp.value;

  set __stdinp(ffi.Pointer<FILE> value) => ___stdinp.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stdoutp =
      _lookup<ffi.Pointer<FILE>>('__stdoutp');

  ffi.Pointer<FILE> get __stdoutp => ___stdoutp.value;

  set __stdoutp(ffi.Pointer<FILE> value) => ___stdoutp.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stderrp =
      _lookup<ffi.Pointer<FILE>>('__stderrp');

  ffi.Pointer<FILE> get __stderrp => ___stderrp.value;

  set __stderrp(ffi.Pointer<FILE> value) => ___stderrp.value = value;

  void clearerr(
    ffi.Pointer<FILE> arg0,
  ) {
    return _clearerr(
      arg0,
    );
  }

  late final _clearerrPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'clearerr');
  late final _clearerr =
      _clearerrPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int fclose(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fclose(
      arg0,
    );
  }

  late final _fclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fclose');
  late final _fclose = _fclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int feof(
    ffi.Pointer<FILE> arg0,
  ) {
    return _feof(
      arg0,
    );
  }

  late final _feofPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('feof');
  late final _feof = _feofPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int ferror(
    ffi.Pointer<FILE> arg0,
  ) {
    return _ferror(
      arg0,
    );
  }

  late final _ferrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ferror');
  late final _ferror = _ferrorPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fflush(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fflush(
      arg0,
    );
  }

  late final _fflushPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fflush');
  late final _fflush = _fflushPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fgetc(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fgetc(
      arg0,
    );
  }

  late final _fgetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('fgetc');
  late final _fgetc = _fgetcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fgetpos(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<fpos_t> arg1,
  ) {
    return _fgetpos(
      arg0,
      arg1,
    );
  }

  late final _fgetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fgetpos');
  late final _fgetpos = _fgetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  ffi.Pointer<ffi.Char> fgets(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    ffi.Pointer<FILE> arg2,
  ) {
    return _fgets(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fgetsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<FILE>)>>('fgets');
  late final _fgets = _fgetsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fopen(
    ffi.Pointer<ffi.Char> __filename,
    ffi.Pointer<ffi.Char> __mode,
  ) {
    return _fopen(
      __filename,
      __mode,
    );
  }

  late final _fopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('fopen');
  late final _fopen = _fopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fprintf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _fprintf(
      arg0,
      arg1,
    );
  }

  late final _fprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fprintf');
  late final _fprintf = _fprintfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int fputc(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _fputc(
      arg0,
      arg1,
    );
  }

  late final _fputcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'fputc');
  late final _fputc =
      _fputcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int fputs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _fputs(
      arg0,
      arg1,
    );
  }

  late final _fputsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('fputs');
  late final _fputs = _fputsPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  int fread(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __nitems,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fread(
      __ptr,
      __size,
      __nitems,
      __stream,
    );
  }

  late final _freadPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fread');
  late final _fread = _freadPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> freopen(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<FILE> arg2,
  ) {
    return _freopen(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _freopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('freopen');
  late final _freopen = _freopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  int fscanf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _fscanf(
      arg0,
      arg1,
    );
  }

  late final _fscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fscanf');
  late final _fscanf = _fscanfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int fseek(
    ffi.Pointer<FILE> arg0,
    int arg1,
    int arg2,
  ) {
    return _fseek(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fseekPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Long, ffi.Int)>>('fseek');
  late final _fseek =
      _fseekPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int fsetpos(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<fpos_t> arg1,
  ) {
    return _fsetpos(
      arg0,
      arg1,
    );
  }

  late final _fsetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fsetpos');
  late final _fsetpos = _fsetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  int ftell(
    ffi.Pointer<FILE> arg0,
  ) {
    return _ftell(
      arg0,
    );
  }

  late final _ftellPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<FILE>)>>(
          'ftell');
  late final _ftell = _ftellPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fwrite(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __nitems,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fwrite(
      __ptr,
      __size,
      __nitems,
      __stream,
    );
  }

  late final _fwritePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fwrite');
  late final _fwrite = _fwritePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int getc(
    ffi.Pointer<FILE> arg0,
  ) {
    return _getc(
      arg0,
    );
  }

  late final _getcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getc');
  late final _getc = _getcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar() {
    return _getchar();
  }

  late final _getcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar');
  late final _getchar = _getcharPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> gets(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _gets(
      arg0,
    );
  }

  late final _getsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('gets');
  late final _gets = _getsPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void perror(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _perror(
      arg0,
    );
  }

  late final _perrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'perror');
  late final _perror =
      _perrorPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int printf(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _printf(
      arg0,
    );
  }

  late final _printfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'printf');
  late final _printf =
      _printfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int putc(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _putc(
      arg0,
      arg1,
    );
  }

  late final _putcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc');
  late final _putc =
      _putcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar(
    int arg0,
  ) {
    return _putchar(
      arg0,
    );
  }

  late final _putcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('putchar');
  late final _putchar = _putcharPtr.asFunction<int Function(int)>();

  int puts(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _puts(
      arg0,
    );
  }

  late final _putsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'puts');
  late final _puts = _putsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int remove(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _remove(
      arg0,
    );
  }

  late final _removePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'remove');
  late final _remove =
      _removePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int rename(
    ffi.Pointer<ffi.Char> __old,
    ffi.Pointer<ffi.Char> __new,
  ) {
    return _rename(
      __old,
      __new,
    );
  }

  late final _renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('rename');
  late final _rename = _renamePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  void rewind(
    ffi.Pointer<FILE> arg0,
  ) {
    return _rewind(
      arg0,
    );
  }

  late final _rewindPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'rewind');
  late final _rewind =
      _rewindPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int scanf(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _scanf(
      arg0,
    );
  }

  late final _scanfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'scanf');
  late final _scanf =
      _scanfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  void setbuf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _setbuf(
      arg0,
      arg1,
    );
  }

  late final _setbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('setbuf');
  late final _setbuf = _setbufPtr
      .asFunction<void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int setvbuf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int arg3,
  ) {
    return _setvbuf(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _setvbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Size)>>('setvbuf');
  late final _setvbuf = _setvbufPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int, int)>();

  int sprintf(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _sprintf(
      arg0,
      arg1,
    );
  }

  late final _sprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sprintf');
  late final _sprintf = _sprintfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int sscanf(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _sscanf(
      arg0,
      arg1,
    );
  }

  late final _sscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sscanf');
  late final _sscanf = _sscanfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> tmpfile() {
    return _tmpfile();
  }

  late final _tmpfilePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<FILE> Function()>>('tmpfile');
  late final _tmpfile = _tmpfilePtr.asFunction<ffi.Pointer<FILE> Function()>();

  ffi.Pointer<ffi.Char> tmpnam(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _tmpnam(
      arg0,
    );
  }

  late final _tmpnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('tmpnam');
  late final _tmpnam = _tmpnamPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int ungetc(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _ungetc(
      arg0,
      arg1,
    );
  }

  late final _ungetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'ungetc');
  late final _ungetc =
      _ungetcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int vfprintf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _vfprintf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _vfprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>>('vfprintf');
  late final _vfprintf = _vfprintfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>();

  int vprintf(
    ffi.Pointer<ffi.Char> arg0,
    va_list arg1,
  ) {
    return _vprintf(
      arg0,
      arg1,
    );
  }

  late final _vprintfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, va_list)>>(
      'vprintf');
  late final _vprintf =
      _vprintfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, va_list)>();

  int vsprintf(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _vsprintf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _vsprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('vsprintf');
  late final _vsprintf = _vsprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  ffi.Pointer<ffi.Char> ctermid(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _ctermid(
      arg0,
    );
  }

  late final _ctermidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('ctermid');
  late final _ctermid = _ctermidPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> fdopen(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _fdopen(
      arg0,
      arg1,
    );
  }

  late final _fdopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('fdopen');
  late final _fdopen = _fdopenPtr
      .asFunction<ffi.Pointer<FILE> Function(int, ffi.Pointer<ffi.Char>)>();

  int fileno(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fileno(
      arg0,
    );
  }

  late final _filenoPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fileno');
  late final _fileno = _filenoPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int pclose(
    ffi.Pointer<FILE> arg0,
  ) {
    return _pclose(
      arg0,
    );
  }

  late final _pclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'pclose');
  late final _pclose = _pclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> popen(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _popen(
      arg0,
      arg1,
    );
  }

  late final _popenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('popen');
  late final _popen = _popenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int __srget(
    ffi.Pointer<FILE> arg0,
  ) {
    return ___srget(
      arg0,
    );
  }

  late final ___srgetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          '__srget');
  late final ___srget =
      ___srgetPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int __svfscanf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return ___svfscanf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final ___svfscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              va_list)>>('__svfscanf');
  late final ___svfscanf = ___svfscanfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>();

  int __swbuf(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return ___swbuf(
      arg0,
      arg1,
    );
  }

  late final ___swbufPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          '__swbuf');
  late final ___swbuf =
      ___swbufPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  void flockfile(
    ffi.Pointer<FILE> arg0,
  ) {
    return _flockfile(
      arg0,
    );
  }

  late final _flockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'flockfile');
  late final _flockfile =
      _flockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int ftrylockfile(
    ffi.Pointer<FILE> arg0,
  ) {
    return _ftrylockfile(
      arg0,
    );
  }

  late final _ftrylockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ftrylockfile');
  late final _ftrylockfile =
      _ftrylockfilePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void funlockfile(
    ffi.Pointer<FILE> arg0,
  ) {
    return _funlockfile(
      arg0,
    );
  }

  late final _funlockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'funlockfile');
  late final _funlockfile =
      _funlockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int getc_unlocked(
    ffi.Pointer<FILE> arg0,
  ) {
    return _getc_unlocked(
      arg0,
    );
  }

  late final _getc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'getc_unlocked');
  late final _getc_unlocked =
      _getc_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar_unlocked() {
    return _getchar_unlocked();
  }

  late final _getchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar_unlocked');
  late final _getchar_unlocked =
      _getchar_unlockedPtr.asFunction<int Function()>();

  int putc_unlocked(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _putc_unlocked(
      arg0,
      arg1,
    );
  }

  late final _putc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc_unlocked');
  late final _putc_unlocked =
      _putc_unlockedPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar_unlocked(
    int arg0,
  ) {
    return _putchar_unlocked(
      arg0,
    );
  }

  late final _putchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'putchar_unlocked');
  late final _putchar_unlocked =
      _putchar_unlockedPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> tempnam(
    ffi.Pointer<ffi.Char> __dir,
    ffi.Pointer<ffi.Char> __prefix,
  ) {
    return _tempnam(
      __dir,
      __prefix,
    );
  }

  late final _tempnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('tempnam');
  late final _tempnam = _tempnamPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fseeko(
    ffi.Pointer<FILE> __stream,
    int __offset,
    int __whence,
  ) {
    return _fseeko(
      __stream,
      __offset,
      __whence,
    );
  }

  late final _fseekoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, off_t, ffi.Int)>>('fseeko');
  late final _fseeko =
      _fseekoPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int ftello(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftello(
      __stream,
    );
  }

  late final _ftelloPtr =
      _lookup<ffi.NativeFunction<off_t Function(ffi.Pointer<FILE>)>>('ftello');
  late final _ftello = _ftelloPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int snprintf(
    ffi.Pointer<ffi.Char> __str,
    int __size,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _snprintf(
      __str,
      __size,
      __format,
    );
  }

  late final _snprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('snprintf');
  late final _snprintf = _snprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int vfscanf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __format,
    va_list arg2,
  ) {
    return _vfscanf(
      __stream,
      __format,
      arg2,
    );
  }

  late final _vfscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>>('vfscanf');
  late final _vfscanf = _vfscanfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>();

  int vscanf(
    ffi.Pointer<ffi.Char> __format,
    va_list arg1,
  ) {
    return _vscanf(
      __format,
      arg1,
    );
  }

  late final _vscanfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, va_list)>>(
      'vscanf');
  late final _vscanf =
      _vscanfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, va_list)>();

  int vsnprintf(
    ffi.Pointer<ffi.Char> __str,
    int __size,
    ffi.Pointer<ffi.Char> __format,
    va_list arg3,
  ) {
    return _vsnprintf(
      __str,
      __size,
      __format,
      arg3,
    );
  }

  late final _vsnprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('vsnprintf');
  late final _vsnprintf = _vsnprintfPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int vsscanf(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Char> __format,
    va_list arg2,
  ) {
    return _vsscanf(
      __str,
      __format,
      arg2,
    );
  }

  late final _vsscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('vsscanf');
  late final _vsscanf = _vsscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int dprintf(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _dprintf(
      arg0,
      arg1,
    );
  }

  late final _dprintfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'dprintf');
  late final _dprintf =
      _dprintfPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  int vdprintf(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _vdprintf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _vdprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, va_list)>>('vdprintf');
  late final _vdprintf = _vdprintfPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, va_list)>();

  int getdelim(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __linep,
    ffi.Pointer<ffi.Size> __linecapp,
    int __delimiter,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getdelim(
      __linep,
      __linecapp,
      __delimiter,
      __stream,
    );
  }

  late final _getdelimPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>, ffi.Int, ffi.Pointer<FILE>)>>('getdelim');
  late final _getdelim = _getdelimPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          int, ffi.Pointer<FILE>)>();

  int getline(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __linep,
    ffi.Pointer<ffi.Size> __linecapp,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getline(
      __linep,
      __linecapp,
      __stream,
    );
  }

  late final _getlinePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>, ffi.Pointer<FILE>)>>('getline');
  late final _getline = _getlinePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fmemopen(
    ffi.Pointer<ffi.Void> __buf,
    int __size,
    ffi.Pointer<ffi.Char> __mode,
  ) {
    return _fmemopen(
      __buf,
      __size,
      __mode,
    );
  }

  late final _fmemopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('fmemopen');
  late final _fmemopen = _fmemopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> open_memstream(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __bufp,
    ffi.Pointer<ffi.Size> __sizep,
  ) {
    return _open_memstream(
      __bufp,
      __sizep,
    );
  }

  late final _open_memstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('open_memstream');
  late final _open_memstream = _open_memstreamPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>)>();

  late final ffi.Pointer<ffi.Int> _sys_nerr = _lookup<ffi.Int>('sys_nerr');

  int get sys_nerr => _sys_nerr.value;

  set sys_nerr(int value) => _sys_nerr.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _sys_errlist =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('sys_errlist');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get sys_errlist => _sys_errlist.value;

  set sys_errlist(ffi.Pointer<ffi.Pointer<ffi.Char>> value) =>
      _sys_errlist.value = value;

  int asprintf(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _asprintf(
      arg0,
      arg1,
    );
  }

  late final _asprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('asprintf');
  late final _asprintf = _asprintfPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> ctermid_r(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _ctermid_r(
      arg0,
    );
  }

  late final _ctermid_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('ctermid_r');
  late final _ctermid_r = _ctermid_rPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> fgetln(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Size> arg1,
  ) {
    return _fgetln(
      arg0,
      arg1,
    );
  }

  late final _fgetlnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Size>)>>('fgetln');
  late final _fgetln = _fgetlnPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<FILE>, ffi.Pointer<ffi.Size>)>();

  ffi.Pointer<ffi.Char> fmtcheck(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _fmtcheck(
      arg0,
      arg1,
    );
  }

  late final _fmtcheckPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('fmtcheck');
  late final _fmtcheck = _fmtcheckPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fpurge(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fpurge(
      arg0,
    );
  }

  late final _fpurgePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fpurge');
  late final _fpurge = _fpurgePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void setbuffer(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _setbuffer(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setbufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int)>>('setbuffer');
  late final _setbuffer = _setbufferPtr.asFunction<
      void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int)>();

  int setlinebuf(
    ffi.Pointer<FILE> arg0,
  ) {
    return _setlinebuf(
      arg0,
    );
  }

  late final _setlinebufPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'setlinebuf');
  late final _setlinebuf =
      _setlinebufPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int vasprintf(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _vasprintf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _vasprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('vasprintf');
  late final _vasprintf = _vasprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  ffi.Pointer<FILE> funopen(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>>
        arg1,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>>
        arg2,
    ffi.Pointer<
            ffi.NativeFunction<
                fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>>
        arg3,
    ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>
        arg4,
  ) {
    return _funopen(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _funopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Char>, ffi.Int)>>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Char>, ffi.Int)>>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>)>>)>>('funopen');
  late final _funopen = _funopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>>,
          ffi.Pointer<
              ffi.NativeFunction<
                  fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>>,
          ffi.Pointer<
              ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>)>();

  int __sprintf_chk(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
  ) {
    return ___sprintf_chk(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final ___sprintf_chkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('__sprintf_chk');
  late final ___sprintf_chk = ___sprintf_chkPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Char>)>();

  int __snprintf_chk(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    int arg3,
    ffi.Pointer<ffi.Char> arg4,
  ) {
    return ___snprintf_chk(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final ___snprintf_chkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('__snprintf_chk');
  late final ___snprintf_chk = ___snprintf_chkPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, int, int, ffi.Pointer<ffi.Char>)>();

  int __vsprintf_chk(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
    va_list arg4,
  ) {
    return ___vsprintf_chk(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final ___vsprintf_chkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('__vsprintf_chk');
  late final ___vsprintf_chk = ___vsprintf_chkPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Char>, va_list)>();

  int __vsnprintf_chk(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    int arg3,
    ffi.Pointer<ffi.Char> arg4,
    va_list arg5,
  ) {
    return ___vsnprintf_chk(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
    );
  }

  late final ___vsnprintf_chkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('__vsnprintf_chk');
  late final ___vsnprintf_chk = ___vsnprintf_chkPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, int, int, ffi.Pointer<ffi.Char>,
          va_list)>();

  ffi.Pointer<ffi.Void> memchr(
    ffi.Pointer<ffi.Void> __s,
    int __c,
    int __n,
  ) {
    return _memchr(
      __s,
      __c,
      __n,
    );
  }

  late final _memchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memchr');
  late final _memchr = _memchrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  int memcmp(
    ffi.Pointer<ffi.Void> __s1,
    ffi.Pointer<ffi.Void> __s2,
    int __n,
  ) {
    return _memcmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _memcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memcmp');
  late final _memcmp = _memcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memcpy(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __n,
  ) {
    return _memcpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _memcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memcpy');
  late final _memcpy = _memcpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memmove(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __len,
  ) {
    return _memmove(
      __dst,
      __src,
      __len,
    );
  }

  late final _memmovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmove');
  late final _memmove = _memmovePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memset(
    ffi.Pointer<ffi.Void> __b,
    int __c,
    int __len,
  ) {
    return _memset(
      __b,
      __c,
      __len,
    );
  }

  late final _memsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memset');
  late final _memset = _memsetPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> strcat(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcat(
      __s1,
      __s2,
    );
  }

  late final _strcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcat');
  late final _strcat = _strcatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strchr(
      __s,
      __c,
    );
  }

  late final _strchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strchr');
  late final _strchr = _strchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strcmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcmp(
      __s1,
      __s2,
    );
  }

  late final _strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcmp');
  late final _strcmp = _strcmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcoll(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcoll(
      __s1,
      __s2,
    );
  }

  late final _strcollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcoll');
  late final _strcoll = _strcollPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _strcpy(
      __dst,
      __src,
    );
  }

  late final _strcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcpy');
  late final _strcpy = _strcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strcspn(
      __s,
      __charset,
    );
  }

  late final _strcspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcspn');
  late final _strcspn = _strcspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strerror(
    int __errnum,
  ) {
    return _strerror(
      __errnum,
    );
  }

  late final _strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strerror');
  late final _strerror =
      _strerrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int strlen(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _strlen(
      __s,
    );
  }

  late final _strlenPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>)>>(
      'strlen');
  late final _strlen =
      _strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strncat(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncat(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncat');
  late final _strncat = _strncatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strncmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncmp');
  late final _strncmp = _strncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strncpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strncpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _strncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncpy');
  late final _strncpy = _strncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strpbrk(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strpbrk(
      __s,
      __charset,
    );
  }

  late final _strpbrkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strpbrk');
  late final _strpbrk = _strpbrkPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strrchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strrchr(
      __s,
      __c,
    );
  }

  late final _strrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strrchr');
  late final _strrchr = _strrchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strspn(
      __s,
      __charset,
    );
  }

  late final _strspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strspn');
  late final _strspn = _strspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strstr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
  ) {
    return _strstr(
      __big,
      __little,
    );
  }

  late final _strstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strstr');
  late final _strstr = _strstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strtok(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Char> __sep,
  ) {
    return _strtok(
      __str,
      __sep,
    );
  }

  late final _strtokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strtok');
  late final _strtok = _strtokPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strxfrm(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strxfrm(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strxfrmPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strxfrm');
  late final _strxfrm = _strxfrmPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strtok_r(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Char> __sep,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lasts,
  ) {
    return _strtok_r(
      __str,
      __sep,
      __lasts,
    );
  }

  late final _strtok_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtok_r');
  late final _strtok_r = _strtok_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strerror_r(
    int __errnum,
    ffi.Pointer<ffi.Char> __strerrbuf,
    int __buflen,
  ) {
    return _strerror_r(
      __errnum,
      __strerrbuf,
      __buflen,
    );
  }

  late final _strerror_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('strerror_r');
  late final _strerror_r = _strerror_rPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strdup(
    ffi.Pointer<ffi.Char> __s1,
  ) {
    return _strdup(
      __s1,
    );
  }

  late final _strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strdup');
  late final _strdup = _strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> memccpy(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __c,
    int __n,
  ) {
    return _memccpy(
      __dst,
      __src,
      __c,
      __n,
    );
  }

  late final _memccpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memccpy');
  late final _memccpy = _memccpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> stpcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _stpcpy(
      __dst,
      __src,
    );
  }

  late final _stpcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('stpcpy');
  late final _stpcpy = _stpcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> stpncpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _stpncpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _stpncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('stpncpy');
  late final _stpncpy = _stpncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strndup(
    ffi.Pointer<ffi.Char> __s1,
    int __n,
  ) {
    return _strndup(
      __s1,
      __n,
    );
  }

  late final _strndupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strndup');
  late final _strndup = _strndupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strnlen(
    ffi.Pointer<ffi.Char> __s1,
    int __n,
  ) {
    return _strnlen(
      __s1,
      __n,
    );
  }

  late final _strnlenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('strnlen');
  late final _strnlen =
      _strnlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strsignal(
    int __sig,
  ) {
    return _strsignal(
      __sig,
    );
  }

  late final _strsignalPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strsignal');
  late final _strsignal =
      _strsignalPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int memset_s(
    ffi.Pointer<ffi.Void> __s,
    int __smax,
    int __c,
    int __n,
  ) {
    return _memset_s(
      __s,
      __smax,
      __c,
      __n,
    );
  }

  late final _memset_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Void>, rsize_t, ffi.Int, rsize_t)>>('memset_s');
  late final _memset_s = _memset_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  ffi.Pointer<ffi.Void> memmem(
    ffi.Pointer<ffi.Void> __big,
    int __big_len,
    ffi.Pointer<ffi.Void> __little,
    int __little_len,
  ) {
    return _memmem(
      __big,
      __big_len,
      __little,
      __little_len,
    );
  }

  late final _memmemPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmem');
  late final _memmem = _memmemPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern4(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern4,
    int __len,
  ) {
    return _memset_pattern4(
      __b,
      __pattern4,
      __len,
    );
  }

  late final _memset_pattern4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern4');
  late final _memset_pattern4 = _memset_pattern4Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern8(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern8,
    int __len,
  ) {
    return _memset_pattern8(
      __b,
      __pattern8,
      __len,
    );
  }

  late final _memset_pattern8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern8');
  late final _memset_pattern8 = _memset_pattern8Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern16(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern16,
    int __len,
  ) {
    return _memset_pattern16(
      __b,
      __pattern16,
      __len,
    );
  }

  late final _memset_pattern16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern16');
  late final _memset_pattern16 = _memset_pattern16Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> strcasestr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
  ) {
    return _strcasestr(
      __big,
      __little,
    );
  }

  late final _strcasestrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcasestr');
  late final _strcasestr = _strcasestrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strnstr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
    int __len,
  ) {
    return _strnstr(
      __big,
      __little,
      __len,
    );
  }

  late final _strnstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strnstr');
  late final _strnstr = _strnstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strlcat(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __source,
    int __size,
  ) {
    return _strlcat(
      __dst,
      __source,
      __size,
    );
  }

  late final _strlcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strlcat');
  late final _strlcat = _strlcatPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strlcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __source,
    int __size,
  ) {
    return _strlcpy(
      __dst,
      __source,
      __size,
    );
  }

  late final _strlcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strlcpy');
  late final _strlcpy = _strlcpyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void strmode(
    int __mode,
    ffi.Pointer<ffi.Char> __bp,
  ) {
    return _strmode(
      __mode,
      __bp,
    );
  }

  late final _strmodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('strmode');
  late final _strmode =
      _strmodePtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strsep(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __stringp,
    ffi.Pointer<ffi.Char> __delim,
  ) {
    return _strsep(
      __stringp,
      __delim,
    );
  }

  late final _strsepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('strsep');
  late final _strsep = _strsepPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  void swab(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _swab(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _swabPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ssize_t)>>('swab');
  late final _swab = _swabPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int timingsafe_bcmp(
    ffi.Pointer<ffi.Void> __b1,
    ffi.Pointer<ffi.Void> __b2,
    int __len,
  ) {
    return _timingsafe_bcmp(
      __b1,
      __b2,
      __len,
    );
  }

  late final _timingsafe_bcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('timingsafe_bcmp');
  late final _timingsafe_bcmp = _timingsafe_bcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int strsignal_r(
    int __sig,
    ffi.Pointer<ffi.Char> __strsignalbuf,
    int __buflen,
  ) {
    return _strsignal_r(
      __sig,
      __strsignalbuf,
      __buflen,
    );
  }

  late final _strsignal_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('strsignal_r');
  late final _strsignal_r = _strsignal_rPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int ffs(
    int arg0,
  ) {
    return _ffs(
      arg0,
    );
  }

  late final _ffsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('ffs');
  late final _ffs = _ffsPtr.asFunction<int Function(int)>();

  int strcasecmp(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _strcasecmp(
      arg0,
      arg1,
    );
  }

  late final _strcasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcasecmp');
  late final _strcasecmp = _strcasecmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strncasecmp(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _strncasecmp(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _strncasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncasecmp');
  late final _strncasecmp = _strncasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int ffsl(
    int arg0,
  ) {
    return _ffsl(
      arg0,
    );
  }

  late final _ffslPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('ffsl');
  late final _ffsl = _ffslPtr.asFunction<int Function(int)>();

  int ffsll(
    int arg0,
  ) {
    return _ffsll(
      arg0,
    );
  }

  late final _ffsllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.LongLong)>>('ffsll');
  late final _ffsll = _ffsllPtr.asFunction<int Function(int)>();

  int fls(
    int arg0,
  ) {
    return _fls(
      arg0,
    );
  }

  late final _flsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fls');
  late final _fls = _flsPtr.asFunction<int Function(int)>();

  int flsl(
    int arg0,
  ) {
    return _flsl(
      arg0,
    );
  }

  late final _flslPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('flsl');
  late final _flsl = _flslPtr.asFunction<int Function(int)>();

  int flsll(
    int arg0,
  ) {
    return _flsll(
      arg0,
    );
  }

  late final _flsllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.LongLong)>>('flsll');
  late final _flsll = _flsllPtr.asFunction<int Function(int)>();

  ffi.Pointer<bitset_t> bitset_create() {
    return _bitset_create();
  }

  late final _bitset_createPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<bitset_t> Function()>>(
          'bitset_create');
  late final _bitset_create =
      _bitset_createPtr.asFunction<ffi.Pointer<bitset_t> Function()>();

  ffi.Pointer<bitset_t> bitset_create_with_capacity(
    int size,
  ) {
    return _bitset_create_with_capacity(
      size,
    );
  }

  late final _bitset_create_with_capacityPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<bitset_t> Function(ffi.Size)>>(
          'bitset_create_with_capacity');
  late final _bitset_create_with_capacity = _bitset_create_with_capacityPtr
      .asFunction<ffi.Pointer<bitset_t> Function(int)>();

  void bitset_free(
    ffi.Pointer<bitset_t> bitset,
  ) {
    return _bitset_free(
      bitset,
    );
  }

  late final _bitset_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<bitset_t>)>>(
          'bitset_free');
  late final _bitset_free =
      _bitset_freePtr.asFunction<void Function(ffi.Pointer<bitset_t>)>();

  void bitset_clear(
    ffi.Pointer<bitset_t> bitset,
  ) {
    return _bitset_clear(
      bitset,
    );
  }

  late final _bitset_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<bitset_t>)>>(
          'bitset_clear');
  late final _bitset_clear =
      _bitset_clearPtr.asFunction<void Function(ffi.Pointer<bitset_t>)>();

  void bitset_fill(
    ffi.Pointer<bitset_t> bitset,
  ) {
    return _bitset_fill(
      bitset,
    );
  }

  late final _bitset_fillPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<bitset_t>)>>(
          'bitset_fill');
  late final _bitset_fill =
      _bitset_fillPtr.asFunction<void Function(ffi.Pointer<bitset_t>)>();

  ffi.Pointer<bitset_t> bitset_copy(
    ffi.Pointer<bitset_t> bitset,
  ) {
    return _bitset_copy(
      bitset,
    );
  }

  late final _bitset_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<bitset_t> Function(
              ffi.Pointer<bitset_t>)>>('bitset_copy');
  late final _bitset_copy = _bitset_copyPtr
      .asFunction<ffi.Pointer<bitset_t> Function(ffi.Pointer<bitset_t>)>();

  bool bitset_resize(
    ffi.Pointer<bitset_t> bitset,
    int newarraysize,
    bool padwithzeroes,
  ) {
    return _bitset_resize(
      bitset,
      newarraysize,
      padwithzeroes,
    );
  }

  late final _bitset_resizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<bitset_t>, ffi.Size, ffi.Bool)>>('bitset_resize');
  late final _bitset_resize = _bitset_resizePtr
      .asFunction<bool Function(ffi.Pointer<bitset_t>, int, bool)>();

  int bitset_size_in_bytes(
    ffi.Pointer<bitset_t> bitset,
  ) {
    return _bitset_size_in_bytes(
      bitset,
    );
  }

  late final _bitset_size_in_bytesPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<bitset_t>)>>(
          'bitset_size_in_bytes');
  late final _bitset_size_in_bytes = _bitset_size_in_bytesPtr
      .asFunction<int Function(ffi.Pointer<bitset_t>)>();

  int bitset_size_in_bits(
    ffi.Pointer<bitset_t> bitset,
  ) {
    return _bitset_size_in_bits(
      bitset,
    );
  }

  late final _bitset_size_in_bitsPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<bitset_t>)>>(
          'bitset_size_in_bits');
  late final _bitset_size_in_bits =
      _bitset_size_in_bitsPtr.asFunction<int Function(ffi.Pointer<bitset_t>)>();

  int bitset_size_in_words(
    ffi.Pointer<bitset_t> bitset,
  ) {
    return _bitset_size_in_words(
      bitset,
    );
  }

  late final _bitset_size_in_wordsPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<bitset_t>)>>(
          'bitset_size_in_words');
  late final _bitset_size_in_words = _bitset_size_in_wordsPtr
      .asFunction<int Function(ffi.Pointer<bitset_t>)>();

  bool bitset_grow(
    ffi.Pointer<bitset_t> bitset,
    int newarraysize,
  ) {
    return _bitset_grow(
      bitset,
      newarraysize,
    );
  }

  late final _bitset_growPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<bitset_t>, ffi.Size)>>('bitset_grow');
  late final _bitset_grow =
      _bitset_growPtr.asFunction<bool Function(ffi.Pointer<bitset_t>, int)>();

  bool bitset_trim(
    ffi.Pointer<bitset_t> bitset,
  ) {
    return _bitset_trim(
      bitset,
    );
  }

  late final _bitset_trimPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<bitset_t>)>>(
          'bitset_trim');
  late final _bitset_trim =
      _bitset_trimPtr.asFunction<bool Function(ffi.Pointer<bitset_t>)>();

  void bitset_shift_left(
    ffi.Pointer<bitset_t> bitset,
    int s,
  ) {
    return _bitset_shift_left(
      bitset,
      s,
    );
  }

  late final _bitset_shift_leftPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<bitset_t>, ffi.Size)>>('bitset_shift_left');
  late final _bitset_shift_left = _bitset_shift_leftPtr
      .asFunction<void Function(ffi.Pointer<bitset_t>, int)>();

  void bitset_shift_right(
    ffi.Pointer<bitset_t> bitset,
    int s,
  ) {
    return _bitset_shift_right(
      bitset,
      s,
    );
  }

  late final _bitset_shift_rightPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<bitset_t>, ffi.Size)>>('bitset_shift_right');
  late final _bitset_shift_right = _bitset_shift_rightPtr
      .asFunction<void Function(ffi.Pointer<bitset_t>, int)>();

  void bitset_set(
    ffi.Pointer<bitset_t> bitset,
    int i,
  ) {
    return _bitset_set(
      bitset,
      i,
    );
  }

  late final _bitset_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<bitset_t>, ffi.Size)>>('bitset_set');
  late final _bitset_set =
      _bitset_setPtr.asFunction<void Function(ffi.Pointer<bitset_t>, int)>();

  void bitset_set_to_value(
    ffi.Pointer<bitset_t> bitset,
    int i,
    bool flag,
  ) {
    return _bitset_set_to_value(
      bitset,
      i,
      flag,
    );
  }

  late final _bitset_set_to_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<bitset_t>, ffi.Size,
              ffi.Bool)>>('bitset_set_to_value');
  late final _bitset_set_to_value = _bitset_set_to_valuePtr
      .asFunction<void Function(ffi.Pointer<bitset_t>, int, bool)>();

  bool bitset_get(
    ffi.Pointer<bitset_t> bitset,
    int i,
  ) {
    return _bitset_get(
      bitset,
      i,
    );
  }

  late final _bitset_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<bitset_t>, ffi.Size)>>('bitset_get');
  late final _bitset_get =
      _bitset_getPtr.asFunction<bool Function(ffi.Pointer<bitset_t>, int)>();

  int bitset_count(
    ffi.Pointer<bitset_t> bitset,
  ) {
    return _bitset_count(
      bitset,
    );
  }

  late final _bitset_countPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<bitset_t>)>>(
          'bitset_count');
  late final _bitset_count =
      _bitset_countPtr.asFunction<int Function(ffi.Pointer<bitset_t>)>();

  int bitset_minimum(
    ffi.Pointer<bitset_t> bitset,
  ) {
    return _bitset_minimum(
      bitset,
    );
  }

  late final _bitset_minimumPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<bitset_t>)>>(
          'bitset_minimum');
  late final _bitset_minimum =
      _bitset_minimumPtr.asFunction<int Function(ffi.Pointer<bitset_t>)>();

  int bitset_maximum(
    ffi.Pointer<bitset_t> bitset,
  ) {
    return _bitset_maximum(
      bitset,
    );
  }

  late final _bitset_maximumPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<bitset_t>)>>(
          'bitset_maximum');
  late final _bitset_maximum =
      _bitset_maximumPtr.asFunction<int Function(ffi.Pointer<bitset_t>)>();

  bool bitset_inplace_union(
    ffi.Pointer<bitset_t> b1,
    ffi.Pointer<bitset_t> b2,
  ) {
    return _bitset_inplace_union(
      b1,
      b2,
    );
  }

  late final _bitset_inplace_unionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<bitset_t>,
              ffi.Pointer<bitset_t>)>>('bitset_inplace_union');
  late final _bitset_inplace_union = _bitset_inplace_unionPtr.asFunction<
      bool Function(ffi.Pointer<bitset_t>, ffi.Pointer<bitset_t>)>();

  int bitset_union_count(
    ffi.Pointer<bitset_t> b1,
    ffi.Pointer<bitset_t> b2,
  ) {
    return _bitset_union_count(
      b1,
      b2,
    );
  }

  late final _bitset_union_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<bitset_t>,
              ffi.Pointer<bitset_t>)>>('bitset_union_count');
  late final _bitset_union_count = _bitset_union_countPtr
      .asFunction<int Function(ffi.Pointer<bitset_t>, ffi.Pointer<bitset_t>)>();

  void bitset_inplace_intersection(
    ffi.Pointer<bitset_t> b1,
    ffi.Pointer<bitset_t> b2,
  ) {
    return _bitset_inplace_intersection(
      b1,
      b2,
    );
  }

  late final _bitset_inplace_intersectionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<bitset_t>,
              ffi.Pointer<bitset_t>)>>('bitset_inplace_intersection');
  late final _bitset_inplace_intersection =
      _bitset_inplace_intersectionPtr.asFunction<
          void Function(ffi.Pointer<bitset_t>, ffi.Pointer<bitset_t>)>();

  int bitset_intersection_count(
    ffi.Pointer<bitset_t> b1,
    ffi.Pointer<bitset_t> b2,
  ) {
    return _bitset_intersection_count(
      b1,
      b2,
    );
  }

  late final _bitset_intersection_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<bitset_t>,
              ffi.Pointer<bitset_t>)>>('bitset_intersection_count');
  late final _bitset_intersection_count = _bitset_intersection_countPtr
      .asFunction<int Function(ffi.Pointer<bitset_t>, ffi.Pointer<bitset_t>)>();

  bool bitsets_disjoint(
    ffi.Pointer<bitset_t> b1,
    ffi.Pointer<bitset_t> b2,
  ) {
    return _bitsets_disjoint(
      b1,
      b2,
    );
  }

  late final _bitsets_disjointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<bitset_t>,
              ffi.Pointer<bitset_t>)>>('bitsets_disjoint');
  late final _bitsets_disjoint = _bitsets_disjointPtr.asFunction<
      bool Function(ffi.Pointer<bitset_t>, ffi.Pointer<bitset_t>)>();

  bool bitsets_intersect(
    ffi.Pointer<bitset_t> b1,
    ffi.Pointer<bitset_t> b2,
  ) {
    return _bitsets_intersect(
      b1,
      b2,
    );
  }

  late final _bitsets_intersectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<bitset_t>,
              ffi.Pointer<bitset_t>)>>('bitsets_intersect');
  late final _bitsets_intersect = _bitsets_intersectPtr.asFunction<
      bool Function(ffi.Pointer<bitset_t>, ffi.Pointer<bitset_t>)>();

  bool bitset_contains_all(
    ffi.Pointer<bitset_t> b1,
    ffi.Pointer<bitset_t> b2,
  ) {
    return _bitset_contains_all(
      b1,
      b2,
    );
  }

  late final _bitset_contains_allPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<bitset_t>,
              ffi.Pointer<bitset_t>)>>('bitset_contains_all');
  late final _bitset_contains_all = _bitset_contains_allPtr.asFunction<
      bool Function(ffi.Pointer<bitset_t>, ffi.Pointer<bitset_t>)>();

  void bitset_inplace_difference(
    ffi.Pointer<bitset_t> b1,
    ffi.Pointer<bitset_t> b2,
  ) {
    return _bitset_inplace_difference(
      b1,
      b2,
    );
  }

  late final _bitset_inplace_differencePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<bitset_t>,
              ffi.Pointer<bitset_t>)>>('bitset_inplace_difference');
  late final _bitset_inplace_difference =
      _bitset_inplace_differencePtr.asFunction<
          void Function(ffi.Pointer<bitset_t>, ffi.Pointer<bitset_t>)>();

  int bitset_difference_count(
    ffi.Pointer<bitset_t> b1,
    ffi.Pointer<bitset_t> b2,
  ) {
    return _bitset_difference_count(
      b1,
      b2,
    );
  }

  late final _bitset_difference_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<bitset_t>,
              ffi.Pointer<bitset_t>)>>('bitset_difference_count');
  late final _bitset_difference_count = _bitset_difference_countPtr
      .asFunction<int Function(ffi.Pointer<bitset_t>, ffi.Pointer<bitset_t>)>();

  bool bitset_inplace_symmetric_difference(
    ffi.Pointer<bitset_t> b1,
    ffi.Pointer<bitset_t> b2,
  ) {
    return _bitset_inplace_symmetric_difference(
      b1,
      b2,
    );
  }

  late final _bitset_inplace_symmetric_differencePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<bitset_t>,
              ffi.Pointer<bitset_t>)>>('bitset_inplace_symmetric_difference');
  late final _bitset_inplace_symmetric_difference =
      _bitset_inplace_symmetric_differencePtr.asFunction<
          bool Function(ffi.Pointer<bitset_t>, ffi.Pointer<bitset_t>)>();

  int bitset_symmetric_difference_count(
    ffi.Pointer<bitset_t> b1,
    ffi.Pointer<bitset_t> b2,
  ) {
    return _bitset_symmetric_difference_count(
      b1,
      b2,
    );
  }

  late final _bitset_symmetric_difference_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<bitset_t>,
              ffi.Pointer<bitset_t>)>>('bitset_symmetric_difference_count');
  late final _bitset_symmetric_difference_count =
      _bitset_symmetric_difference_countPtr.asFunction<
          int Function(ffi.Pointer<bitset_t>, ffi.Pointer<bitset_t>)>();

  bool bitset_next_set_bit(
    ffi.Pointer<bitset_t> bitset,
    ffi.Pointer<ffi.Size> i,
  ) {
    return _bitset_next_set_bit(
      bitset,
      i,
    );
  }

  late final _bitset_next_set_bitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<bitset_t>,
              ffi.Pointer<ffi.Size>)>>('bitset_next_set_bit');
  late final _bitset_next_set_bit = _bitset_next_set_bitPtr.asFunction<
      bool Function(ffi.Pointer<bitset_t>, ffi.Pointer<ffi.Size>)>();

  int bitset_next_set_bits(
    ffi.Pointer<bitset_t> bitset,
    ffi.Pointer<ffi.Size> buffer,
    int capacity,
    ffi.Pointer<ffi.Size> startfrom,
  ) {
    return _bitset_next_set_bits(
      bitset,
      buffer,
      capacity,
      startfrom,
    );
  }

  late final _bitset_next_set_bitsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<bitset_t>, ffi.Pointer<ffi.Size>,
              ffi.Size, ffi.Pointer<ffi.Size>)>>('bitset_next_set_bits');
  late final _bitset_next_set_bits = _bitset_next_set_bitsPtr.asFunction<
      int Function(ffi.Pointer<bitset_t>, ffi.Pointer<ffi.Size>, int,
          ffi.Pointer<ffi.Size>)>();

  bool bitset_for_each(
    ffi.Pointer<bitset_t> b,
    bitset_iterator iterator,
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _bitset_for_each(
      b,
      iterator,
      ptr,
    );
  }

  late final _bitset_for_eachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<bitset_t>, bitset_iterator,
              ffi.Pointer<ffi.Void>)>>('bitset_for_each');
  late final _bitset_for_each = _bitset_for_eachPtr.asFunction<
      bool Function(
          ffi.Pointer<bitset_t>, bitset_iterator, ffi.Pointer<ffi.Void>)>();

  void bitset_print(
    ffi.Pointer<bitset_t> b,
  ) {
    return _bitset_print(
      b,
    );
  }

  late final _bitset_printPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<bitset_t>)>>(
          'bitset_print');
  late final _bitset_print =
      _bitset_printPtr.asFunction<void Function(ffi.Pointer<bitset_t>)>();

  /// Dynamically allocates a new bitmap (initially empty).
  /// Returns NULL if the allocation fails.
  /// Capacity is a performance hint for how many "containers" the data will need.
  /// Client is responsible for calling `roaring_bitmap_free()`.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_create_with_capacity(
    int cap,
  ) {
    return _roaring_bitmap_create_with_capacity(
      cap,
    );
  }

  late final _roaring_bitmap_create_with_capacityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(
              ffi.Uint32)>>('roaring_bitmap_create_with_capacity');
  late final _roaring_bitmap_create_with_capacity =
      _roaring_bitmap_create_with_capacityPtr
          .asFunction<ffi.Pointer<roaring_bitmap_t> Function(int)>();

  /// Dynamically allocates a new bitmap (initially empty).
  /// Returns NULL if the allocation fails.
  /// Client is responsible for calling `roaring_bitmap_free()`.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_create() {
    return _roaring_bitmap_create();
  }

  late final _roaring_bitmap_createPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<roaring_bitmap_t> Function()>>(
          'roaring_bitmap_create');
  late final _roaring_bitmap_create = _roaring_bitmap_createPtr
      .asFunction<ffi.Pointer<roaring_bitmap_t> Function()>();

  /// Initialize a roaring bitmap structure in memory controlled by client.
  /// Capacity is a performance hint for how many "containers" the data will need.
  /// Can return false if auxiliary allocations fail when capacity greater than 0.
  bool roaring_bitmap_init_with_capacity(
    ffi.Pointer<roaring_bitmap_t> r,
    int cap,
  ) {
    return _roaring_bitmap_init_with_capacity(
      r,
      cap,
    );
  }

  late final _roaring_bitmap_init_with_capacityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Uint32)>>('roaring_bitmap_init_with_capacity');
  late final _roaring_bitmap_init_with_capacity =
      _roaring_bitmap_init_with_capacityPtr
          .asFunction<bool Function(ffi.Pointer<roaring_bitmap_t>, int)>();

  /// Initialize a roaring bitmap structure in memory controlled by client.
  /// The bitmap will be in a "clear" state, with no auxiliary allocations.
  /// Since this performs no allocations, the function will not fail.
  void roaring_bitmap_init_cleared(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_init_cleared(
      r,
    );
  }

  late final _roaring_bitmap_init_clearedPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_init_cleared');
  late final _roaring_bitmap_init_cleared = _roaring_bitmap_init_clearedPtr
      .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Add all the values between min (included) and max (excluded) that are at a
  /// distance k*step from min.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_from_range(
    int min,
    int max,
    int step,
  ) {
    return _roaring_bitmap_from_range(
      min,
      max,
      step,
    );
  }

  late final _roaring_bitmap_from_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Uint64, ffi.Uint64,
              ffi.Uint32)>>('roaring_bitmap_from_range');
  late final _roaring_bitmap_from_range = _roaring_bitmap_from_rangePtr
      .asFunction<ffi.Pointer<roaring_bitmap_t> Function(int, int, int)>();

  /// Creates a new bitmap from a pointer of uint32_t integers
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_of_ptr(
    int n_args,
    ffi.Pointer<ffi.Uint32> vals,
  ) {
    return _roaring_bitmap_of_ptr(
      n_args,
      vals,
    );
  }

  late final _roaring_bitmap_of_ptrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(
              ffi.Size, ffi.Pointer<ffi.Uint32>)>>('roaring_bitmap_of_ptr');
  late final _roaring_bitmap_of_ptr = _roaring_bitmap_of_ptrPtr.asFunction<
      ffi.Pointer<roaring_bitmap_t> Function(int, ffi.Pointer<ffi.Uint32>)>();

  bool roaring_bitmap_get_copy_on_write(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_get_copy_on_write(
      r,
    );
  }

  late final _roaring_bitmap_get_copy_on_writePtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_get_copy_on_write');
  late final _roaring_bitmap_get_copy_on_write =
      _roaring_bitmap_get_copy_on_writePtr
          .asFunction<bool Function(ffi.Pointer<roaring_bitmap_t>)>();

  void roaring_bitmap_set_copy_on_write(
    ffi.Pointer<roaring_bitmap_t> r,
    bool cow,
  ) {
    return _roaring_bitmap_set_copy_on_write(
      r,
      cow,
    );
  }

  late final _roaring_bitmap_set_copy_on_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Bool)>>('roaring_bitmap_set_copy_on_write');
  late final _roaring_bitmap_set_copy_on_write =
      _roaring_bitmap_set_copy_on_writePtr
          .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>, bool)>();

  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_add_offset(
    ffi.Pointer<roaring_bitmap_t> bm,
    int offset,
  ) {
    return _roaring_bitmap_add_offset(
      bm,
      offset,
    );
  }

  late final _roaring_bitmap_add_offsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Int64)>>('roaring_bitmap_add_offset');
  late final _roaring_bitmap_add_offset =
      _roaring_bitmap_add_offsetPtr.asFunction<
          ffi.Pointer<roaring_bitmap_t> Function(
              ffi.Pointer<roaring_bitmap_t>, int)>();

  /// Describe the inner structure of the bitmap.
  void roaring_bitmap_printf_describe(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_printf_describe(
      r,
    );
  }

  late final _roaring_bitmap_printf_describePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_printf_describe');
  late final _roaring_bitmap_printf_describe =
      _roaring_bitmap_printf_describePtr
          .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Creates a new bitmap from a list of uint32_t integers
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_of(
    int n,
  ) {
    return _roaring_bitmap_of(
      n,
    );
  }

  late final _roaring_bitmap_ofPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<roaring_bitmap_t> Function(ffi.Size)>>(
      'roaring_bitmap_of');
  late final _roaring_bitmap_of = _roaring_bitmap_ofPtr
      .asFunction<ffi.Pointer<roaring_bitmap_t> Function(int)>();

  /// Copies a bitmap (this does memory allocation).
  /// The caller is responsible for memory management.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_copy(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_copy(
      r,
    );
  }

  late final _roaring_bitmap_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_copy');
  late final _roaring_bitmap_copy = _roaring_bitmap_copyPtr.asFunction<
      ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Copies a bitmap from src to dest. It is assumed that the pointer dest
  /// is to an already allocated bitmap. The content of the dest bitmap is
  /// freed/deleted.
  ///
  /// It might be preferable and simpler to call roaring_bitmap_copy except
  /// that roaring_bitmap_overwrite can save on memory allocations.
  bool roaring_bitmap_overwrite(
    ffi.Pointer<roaring_bitmap_t> dest,
    ffi.Pointer<roaring_bitmap_t> src,
  ) {
    return _roaring_bitmap_overwrite(
      dest,
      src,
    );
  }

  late final _roaring_bitmap_overwritePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_overwrite');
  late final _roaring_bitmap_overwrite =
      _roaring_bitmap_overwritePtr.asFunction<
          bool Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Print the content of the bitmap.
  void roaring_bitmap_printf(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_printf(
      r,
    );
  }

  late final _roaring_bitmap_printfPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_printf');
  late final _roaring_bitmap_printf = _roaring_bitmap_printfPtr
      .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Computes the intersection between two bitmaps and returns new bitmap. The
  /// caller is responsible for memory management.
  ///
  /// Performance hint: if you are computing the intersection between several
  /// bitmaps, two-by-two, it is best to start with the smallest bitmap.
  /// You may also rely on roaring_bitmap_and_inplace to avoid creating
  /// many temporary bitmaps.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_and(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_and(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_andPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_and');
  late final _roaring_bitmap_and = _roaring_bitmap_andPtr.asFunction<
      ffi.Pointer<roaring_bitmap_t> Function(
          ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Computes the size of the intersection between two bitmaps.
  int roaring_bitmap_and_cardinality(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_and_cardinality(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_and_cardinalityPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<roaring_bitmap_t>,
                  ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_and_cardinality');
  late final _roaring_bitmap_and_cardinality =
      _roaring_bitmap_and_cardinalityPtr.asFunction<
          int Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Check whether two bitmaps intersect.
  bool roaring_bitmap_intersect(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_intersect(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_intersectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_intersect');
  late final _roaring_bitmap_intersect =
      _roaring_bitmap_intersectPtr.asFunction<
          bool Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Check whether a bitmap and a closed range intersect.
  bool roaring_bitmap_intersect_with_range(
    ffi.Pointer<roaring_bitmap_t> bm,
    int x,
    int y,
  ) {
    return _roaring_bitmap_intersect_with_range(
      bm,
      x,
      y,
    );
  }

  late final _roaring_bitmap_intersect_with_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>, ffi.Uint64,
              ffi.Uint64)>>('roaring_bitmap_intersect_with_range');
  late final _roaring_bitmap_intersect_with_range =
      _roaring_bitmap_intersect_with_rangePtr
          .asFunction<bool Function(ffi.Pointer<roaring_bitmap_t>, int, int)>();

  /// Computes the Jaccard index between two bitmaps. (Also known as the Tanimoto
  /// distance, or the Jaccard similarity coefficient)
  ///
  /// The Jaccard index is undefined if both bitmaps are empty.
  double roaring_bitmap_jaccard_index(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_jaccard_index(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_jaccard_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_jaccard_index');
  late final _roaring_bitmap_jaccard_index =
      _roaring_bitmap_jaccard_indexPtr.asFunction<
          double Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Computes the size of the union between two bitmaps.
  int roaring_bitmap_or_cardinality(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_or_cardinality(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_or_cardinalityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_or_cardinality');
  late final _roaring_bitmap_or_cardinality =
      _roaring_bitmap_or_cardinalityPtr.asFunction<
          int Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Computes the size of the difference (andnot) between two bitmaps.
  int roaring_bitmap_andnot_cardinality(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_andnot_cardinality(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_andnot_cardinalityPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<roaring_bitmap_t>,
                  ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_andnot_cardinality');
  late final _roaring_bitmap_andnot_cardinality =
      _roaring_bitmap_andnot_cardinalityPtr.asFunction<
          int Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Computes the size of the symmetric difference (xor) between two bitmaps.
  int roaring_bitmap_xor_cardinality(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_xor_cardinality(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_xor_cardinalityPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<roaring_bitmap_t>,
                  ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_xor_cardinality');
  late final _roaring_bitmap_xor_cardinality =
      _roaring_bitmap_xor_cardinalityPtr.asFunction<
          int Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Inplace version of `roaring_bitmap_and()`, modifies r1
  /// r1 == r2 is allowed.
  ///
  /// Performance hint: if you are computing the intersection between several
  /// bitmaps, two-by-two, it is best to start with the smallest bitmap.
  void roaring_bitmap_and_inplace(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_and_inplace(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_and_inplacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_and_inplace');
  late final _roaring_bitmap_and_inplace =
      _roaring_bitmap_and_inplacePtr.asFunction<
          void Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Computes the union between two bitmaps and returns new bitmap. The caller is
  /// responsible for memory management.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_or(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_or(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_orPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_or');
  late final _roaring_bitmap_or = _roaring_bitmap_orPtr.asFunction<
      ffi.Pointer<roaring_bitmap_t> Function(
          ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Inplace version of `roaring_bitmap_or(), modifies r1.
  /// TODO: decide whether r1 == r2 ok
  void roaring_bitmap_or_inplace(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_or_inplace(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_or_inplacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_or_inplace');
  late final _roaring_bitmap_or_inplace =
      _roaring_bitmap_or_inplacePtr.asFunction<
          void Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Compute the union of 'number' bitmaps.
  /// Caller is responsible for freeing the result.
  /// See also `roaring_bitmap_or_many_heap()`
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_or_many(
    int number,
    ffi.Pointer<ffi.Pointer<roaring_bitmap_t>> rs,
  ) {
    return _roaring_bitmap_or_many(
      number,
      rs,
    );
  }

  late final _roaring_bitmap_or_manyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<roaring_bitmap_t> Function(
                  ffi.Size, ffi.Pointer<ffi.Pointer<roaring_bitmap_t>>)>>(
      'roaring_bitmap_or_many');
  late final _roaring_bitmap_or_many = _roaring_bitmap_or_manyPtr.asFunction<
      ffi.Pointer<roaring_bitmap_t> Function(
          int, ffi.Pointer<ffi.Pointer<roaring_bitmap_t>>)>();

  /// Compute the union of 'number' bitmaps using a heap. This can sometimes be
  /// faster than `roaring_bitmap_or_many() which uses a naive algorithm.
  /// Caller is responsible for freeing the result.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_or_many_heap(
    int number,
    ffi.Pointer<ffi.Pointer<roaring_bitmap_t>> rs,
  ) {
    return _roaring_bitmap_or_many_heap(
      number,
      rs,
    );
  }

  late final _roaring_bitmap_or_many_heapPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<roaring_bitmap_t> Function(
                  ffi.Uint32, ffi.Pointer<ffi.Pointer<roaring_bitmap_t>>)>>(
      'roaring_bitmap_or_many_heap');
  late final _roaring_bitmap_or_many_heap =
      _roaring_bitmap_or_many_heapPtr.asFunction<
          ffi.Pointer<roaring_bitmap_t> Function(
              int, ffi.Pointer<ffi.Pointer<roaring_bitmap_t>>)>();

  /// Computes the symmetric difference (xor) between two bitmaps
  /// and returns new bitmap. The caller is responsible for memory management.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_xor(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_xor(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_xorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_xor');
  late final _roaring_bitmap_xor = _roaring_bitmap_xorPtr.asFunction<
      ffi.Pointer<roaring_bitmap_t> Function(
          ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Inplace version of roaring_bitmap_xor, modifies r1, r1 != r2.
  void roaring_bitmap_xor_inplace(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_xor_inplace(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_xor_inplacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_xor_inplace');
  late final _roaring_bitmap_xor_inplace =
      _roaring_bitmap_xor_inplacePtr.asFunction<
          void Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Compute the xor of 'number' bitmaps.
  /// Caller is responsible for freeing the result.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_xor_many(
    int number,
    ffi.Pointer<ffi.Pointer<roaring_bitmap_t>> rs,
  ) {
    return _roaring_bitmap_xor_many(
      number,
      rs,
    );
  }

  late final _roaring_bitmap_xor_manyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<roaring_bitmap_t> Function(
                  ffi.Size, ffi.Pointer<ffi.Pointer<roaring_bitmap_t>>)>>(
      'roaring_bitmap_xor_many');
  late final _roaring_bitmap_xor_many = _roaring_bitmap_xor_manyPtr.asFunction<
      ffi.Pointer<roaring_bitmap_t> Function(
          int, ffi.Pointer<ffi.Pointer<roaring_bitmap_t>>)>();

  /// Computes the difference (andnot) between two bitmaps and returns new bitmap.
  /// Caller is responsible for freeing the result.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_andnot(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_andnot(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_andnotPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_andnot');
  late final _roaring_bitmap_andnot = _roaring_bitmap_andnotPtr.asFunction<
      ffi.Pointer<roaring_bitmap_t> Function(
          ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Inplace version of roaring_bitmap_andnot, modifies r1, r1 != r2.
  void roaring_bitmap_andnot_inplace(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_andnot_inplace(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_andnot_inplacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_andnot_inplace');
  late final _roaring_bitmap_andnot_inplace =
      _roaring_bitmap_andnot_inplacePtr.asFunction<
          void Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Frees the memory.
  void roaring_bitmap_free(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_free(
      r,
    );
  }

  late final _roaring_bitmap_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_free');
  late final _roaring_bitmap_free = _roaring_bitmap_freePtr
      .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Add an item, using context from a previous insert for speed optimization.
  ///
  /// `context` will be used to store information between calls to make bulk
  /// operations faster. `*context` should be zero-initialized before the first
  /// call to this function.
  ///
  /// Modifying the bitmap in any way (other than `-bulk` suffixed functions)
  /// will invalidate the stored context, calling this function with a non-zero
  /// context after doing any modification invokes undefined behavior.
  ///
  /// In order to exploit this optimization, the caller should call this function
  /// with values with the same "key" (high 16 bits of the value) consecutively.
  void roaring_bitmap_add_bulk(
    ffi.Pointer<roaring_bitmap_t> r,
    ffi.Pointer<roaring_bulk_context_t> context,
    int val,
  ) {
    return _roaring_bitmap_add_bulk(
      r,
      context,
      val,
    );
  }

  late final _roaring_bitmap_add_bulkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bulk_context_t>,
              ffi.Uint32)>>('roaring_bitmap_add_bulk');
  late final _roaring_bitmap_add_bulk = _roaring_bitmap_add_bulkPtr.asFunction<
      void Function(ffi.Pointer<roaring_bitmap_t>,
          ffi.Pointer<roaring_bulk_context_t>, int)>();

  /// Add value n_args from pointer vals, faster than repeatedly calling
  /// `roaring_bitmap_add()`
  ///
  /// In order to exploit this optimization, the caller should attempt to keep
  /// values with the same "key" (high 16 bits of the value) as consecutive
  /// elements in `vals`
  void roaring_bitmap_add_many(
    ffi.Pointer<roaring_bitmap_t> r,
    int n_args,
    ffi.Pointer<ffi.Uint32> vals,
  ) {
    return _roaring_bitmap_add_many(
      r,
      n_args,
      vals,
    );
  }

  late final _roaring_bitmap_add_manyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>, ffi.Size,
              ffi.Pointer<ffi.Uint32>)>>('roaring_bitmap_add_many');
  late final _roaring_bitmap_add_many = _roaring_bitmap_add_manyPtr.asFunction<
      void Function(
          ffi.Pointer<roaring_bitmap_t>, int, ffi.Pointer<ffi.Uint32>)>();

  /// Add value x
  void roaring_bitmap_add(
    ffi.Pointer<roaring_bitmap_t> r,
    int x,
  ) {
    return _roaring_bitmap_add(
      r,
      x,
    );
  }

  late final _roaring_bitmap_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Uint32)>>('roaring_bitmap_add');
  late final _roaring_bitmap_add = _roaring_bitmap_addPtr
      .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>, int)>();

  /// Add value x
  /// Returns true if a new value was added, false if the value already existed.
  bool roaring_bitmap_add_checked(
    ffi.Pointer<roaring_bitmap_t> r,
    int x,
  ) {
    return _roaring_bitmap_add_checked(
      r,
      x,
    );
  }

  late final _roaring_bitmap_add_checkedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Uint32)>>('roaring_bitmap_add_checked');
  late final _roaring_bitmap_add_checked = _roaring_bitmap_add_checkedPtr
      .asFunction<bool Function(ffi.Pointer<roaring_bitmap_t>, int)>();

  /// Add all values in range [min, max]
  void roaring_bitmap_add_range_closed(
    ffi.Pointer<roaring_bitmap_t> r,
    int min,
    int max,
  ) {
    return _roaring_bitmap_add_range_closed(
      r,
      min,
      max,
    );
  }

  late final _roaring_bitmap_add_range_closedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>, ffi.Uint32,
              ffi.Uint32)>>('roaring_bitmap_add_range_closed');
  late final _roaring_bitmap_add_range_closed =
      _roaring_bitmap_add_range_closedPtr
          .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>, int, int)>();

  /// Add all values in range [min, max)
  void roaring_bitmap_add_range(
    ffi.Pointer<roaring_bitmap_t> r,
    int min,
    int max,
  ) {
    return _roaring_bitmap_add_range(
      r,
      min,
      max,
    );
  }

  late final _roaring_bitmap_add_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>, ffi.Uint64,
              ffi.Uint64)>>('roaring_bitmap_add_range');
  late final _roaring_bitmap_add_range = _roaring_bitmap_add_rangePtr
      .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>, int, int)>();

  /// Remove value x
  void roaring_bitmap_remove(
    ffi.Pointer<roaring_bitmap_t> r,
    int x,
  ) {
    return _roaring_bitmap_remove(
      r,
      x,
    );
  }

  late final _roaring_bitmap_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Uint32)>>('roaring_bitmap_remove');
  late final _roaring_bitmap_remove = _roaring_bitmap_removePtr
      .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>, int)>();

  /// Remove all values in range [min, max]
  void roaring_bitmap_remove_range_closed(
    ffi.Pointer<roaring_bitmap_t> r,
    int min,
    int max,
  ) {
    return _roaring_bitmap_remove_range_closed(
      r,
      min,
      max,
    );
  }

  late final _roaring_bitmap_remove_range_closedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>, ffi.Uint32,
              ffi.Uint32)>>('roaring_bitmap_remove_range_closed');
  late final _roaring_bitmap_remove_range_closed =
      _roaring_bitmap_remove_range_closedPtr
          .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>, int, int)>();

  /// Remove all values in range [min, max)
  void roaring_bitmap_remove_range(
    ffi.Pointer<roaring_bitmap_t> r,
    int min,
    int max,
  ) {
    return _roaring_bitmap_remove_range(
      r,
      min,
      max,
    );
  }

  late final _roaring_bitmap_remove_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>, ffi.Uint64,
              ffi.Uint64)>>('roaring_bitmap_remove_range');
  late final _roaring_bitmap_remove_range = _roaring_bitmap_remove_rangePtr
      .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>, int, int)>();

  /// Remove multiple values
  void roaring_bitmap_remove_many(
    ffi.Pointer<roaring_bitmap_t> r,
    int n_args,
    ffi.Pointer<ffi.Uint32> vals,
  ) {
    return _roaring_bitmap_remove_many(
      r,
      n_args,
      vals,
    );
  }

  late final _roaring_bitmap_remove_manyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>, ffi.Size,
              ffi.Pointer<ffi.Uint32>)>>('roaring_bitmap_remove_many');
  late final _roaring_bitmap_remove_many =
      _roaring_bitmap_remove_manyPtr.asFunction<
          void Function(
              ffi.Pointer<roaring_bitmap_t>, int, ffi.Pointer<ffi.Uint32>)>();

  /// Remove value x
  /// Returns true if a new value was removed, false if the value was not existing.
  bool roaring_bitmap_remove_checked(
    ffi.Pointer<roaring_bitmap_t> r,
    int x,
  ) {
    return _roaring_bitmap_remove_checked(
      r,
      x,
    );
  }

  late final _roaring_bitmap_remove_checkedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Uint32)>>('roaring_bitmap_remove_checked');
  late final _roaring_bitmap_remove_checked = _roaring_bitmap_remove_checkedPtr
      .asFunction<bool Function(ffi.Pointer<roaring_bitmap_t>, int)>();

  /// Check if value is present
  bool roaring_bitmap_contains(
    ffi.Pointer<roaring_bitmap_t> r,
    int val,
  ) {
    return _roaring_bitmap_contains(
      r,
      val,
    );
  }

  late final _roaring_bitmap_containsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Uint32)>>('roaring_bitmap_contains');
  late final _roaring_bitmap_contains = _roaring_bitmap_containsPtr
      .asFunction<bool Function(ffi.Pointer<roaring_bitmap_t>, int)>();

  /// Check whether a range of values from range_start (included)
  /// to range_end (excluded) is present
  bool roaring_bitmap_contains_range(
    ffi.Pointer<roaring_bitmap_t> r,
    int range_start,
    int range_end,
  ) {
    return _roaring_bitmap_contains_range(
      r,
      range_start,
      range_end,
    );
  }

  late final _roaring_bitmap_contains_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>, ffi.Uint64,
              ffi.Uint64)>>('roaring_bitmap_contains_range');
  late final _roaring_bitmap_contains_range = _roaring_bitmap_contains_rangePtr
      .asFunction<bool Function(ffi.Pointer<roaring_bitmap_t>, int, int)>();

  /// Check if an items is present, using context from a previous insert for speed
  /// optimization.
  ///
  /// `context` will be used to store information between calls to make bulk
  /// operations faster. `*context` should be zero-initialized before the first
  /// call to this function.
  ///
  /// Modifying the bitmap in any way (other than `-bulk` suffixed functions)
  /// will invalidate the stored context, calling this function with a non-zero
  /// context after doing any modification invokes undefined behavior.
  ///
  /// In order to exploit this optimization, the caller should call this function
  /// with values with the same "key" (high 16 bits of the value) consecutively.
  bool roaring_bitmap_contains_bulk(
    ffi.Pointer<roaring_bitmap_t> r,
    ffi.Pointer<roaring_bulk_context_t> context,
    int val,
  ) {
    return _roaring_bitmap_contains_bulk(
      r,
      context,
      val,
    );
  }

  late final _roaring_bitmap_contains_bulkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bulk_context_t>,
              ffi.Uint32)>>('roaring_bitmap_contains_bulk');
  late final _roaring_bitmap_contains_bulk =
      _roaring_bitmap_contains_bulkPtr.asFunction<
          bool Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bulk_context_t>, int)>();

  /// Get the cardinality of the bitmap (number of elements).
  int roaring_bitmap_get_cardinality(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_get_cardinality(
      r,
    );
  }

  late final _roaring_bitmap_get_cardinalityPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_get_cardinality');
  late final _roaring_bitmap_get_cardinality =
      _roaring_bitmap_get_cardinalityPtr
          .asFunction<int Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Returns the number of elements in the range [range_start, range_end).
  int roaring_bitmap_range_cardinality(
    ffi.Pointer<roaring_bitmap_t> r,
    int range_start,
    int range_end,
  ) {
    return _roaring_bitmap_range_cardinality(
      r,
      range_start,
      range_end,
    );
  }

  late final _roaring_bitmap_range_cardinalityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(ffi.Pointer<roaring_bitmap_t>, ffi.Uint64,
              ffi.Uint64)>>('roaring_bitmap_range_cardinality');
  late final _roaring_bitmap_range_cardinality =
      _roaring_bitmap_range_cardinalityPtr
          .asFunction<int Function(ffi.Pointer<roaring_bitmap_t>, int, int)>();

  /// Returns true if the bitmap is empty (cardinality is zero).
  bool roaring_bitmap_is_empty(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_is_empty(
      r,
    );
  }

  late final _roaring_bitmap_is_emptyPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_is_empty');
  late final _roaring_bitmap_is_empty = _roaring_bitmap_is_emptyPtr
      .asFunction<bool Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Empties the bitmap.  It will have no auxiliary allocations (so if the bitmap
  /// was initialized in client memory via roaring_bitmap_init(), then a call to
  /// roaring_bitmap_clear() would be enough to "free" it)
  void roaring_bitmap_clear(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_clear(
      r,
    );
  }

  late final _roaring_bitmap_clearPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_clear');
  late final _roaring_bitmap_clear = _roaring_bitmap_clearPtr
      .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Convert the bitmap to a sorted array, output in `ans`.
  ///
  /// Caller is responsible to ensure that there is enough memory allocated, e.g.
  ///
  /// ans = malloc(roaring_bitmap_get_cardinality(bitmap) * sizeof(uint32_t));
  void roaring_bitmap_to_uint32_array(
    ffi.Pointer<roaring_bitmap_t> r,
    ffi.Pointer<ffi.Uint32> ans,
  ) {
    return _roaring_bitmap_to_uint32_array(
      r,
      ans,
    );
  }

  late final _roaring_bitmap_to_uint32_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<ffi.Uint32>)>>('roaring_bitmap_to_uint32_array');
  late final _roaring_bitmap_to_uint32_array =
      _roaring_bitmap_to_uint32_arrayPtr.asFunction<
          void Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<ffi.Uint32>)>();

  /// Store the bitmap to a bitset. This can be useful for people
  /// who need the performance and simplicity of a standard bitset.
  /// We assume that the input bitset is originally empty (does not
  /// have any set bit).
  ///
  /// bitset_t * out = bitset_create();
  /// // if the bitset has content in it, call "bitset_clear(out)"
  /// bool success = roaring_bitmap_to_bitset(mybitmap, out);
  /// // on failure, success will be false.
  /// // You can then query the bitset:
  /// bool is_present = bitset_get(out,  10011 );
  /// // you must free the memory:
  /// bitset_free(out);
  bool roaring_bitmap_to_bitset(
    ffi.Pointer<roaring_bitmap_t> r,
    ffi.Pointer<bitset_t> bitset,
  ) {
    return _roaring_bitmap_to_bitset(
      r,
      bitset,
    );
  }

  late final _roaring_bitmap_to_bitsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<bitset_t>)>>('roaring_bitmap_to_bitset');
  late final _roaring_bitmap_to_bitset =
      _roaring_bitmap_to_bitsetPtr.asFunction<
          bool Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<bitset_t>)>();

  /// Convert the bitmap to a sorted array from `offset` by `limit`, output in `ans`.
  ///
  /// Caller is responsible to ensure that there is enough memory allocated, e.g.
  ///
  /// ans = malloc(roaring_bitmap_get_cardinality(limit) * sizeof(uint32_t));
  ///
  /// Return false in case of failure (e.g., insufficient memory)
  bool roaring_bitmap_range_uint32_array(
    ffi.Pointer<roaring_bitmap_t> r,
    int offset,
    int limit,
    ffi.Pointer<ffi.Uint32> ans,
  ) {
    return _roaring_bitmap_range_uint32_array(
      r,
      offset,
      limit,
      ans,
    );
  }

  late final _roaring_bitmap_range_uint32_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>, ffi.Size, ffi.Size,
              ffi.Pointer<ffi.Uint32>)>>('roaring_bitmap_range_uint32_array');
  late final _roaring_bitmap_range_uint32_array =
      _roaring_bitmap_range_uint32_arrayPtr.asFunction<
          bool Function(ffi.Pointer<roaring_bitmap_t>, int, int,
              ffi.Pointer<ffi.Uint32>)>();

  /// Remove run-length encoding even when it is more space efficient.
  /// Return whether a change was applied.
  bool roaring_bitmap_remove_run_compression(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_remove_run_compression(
      r,
    );
  }

  late final _roaring_bitmap_remove_run_compressionPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_remove_run_compression');
  late final _roaring_bitmap_remove_run_compression =
      _roaring_bitmap_remove_run_compressionPtr
          .asFunction<bool Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Convert array and bitmap containers to run containers when it is more
  /// efficient; also convert from run containers when more space efficient.
  ///
  /// Returns true if the result has at least one run container.
  /// Additional savings might be possible by calling `shrinkToFit()`.
  bool roaring_bitmap_run_optimize(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_run_optimize(
      r,
    );
  }

  late final _roaring_bitmap_run_optimizePtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_run_optimize');
  late final _roaring_bitmap_run_optimize = _roaring_bitmap_run_optimizePtr
      .asFunction<bool Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// If needed, reallocate memory to shrink the memory usage.
  /// Returns the number of bytes saved.
  int roaring_bitmap_shrink_to_fit(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_shrink_to_fit(
      r,
    );
  }

  late final _roaring_bitmap_shrink_to_fitPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_shrink_to_fit');
  late final _roaring_bitmap_shrink_to_fit = _roaring_bitmap_shrink_to_fitPtr
      .asFunction<int Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Write the bitmap to an output pointer, this output buffer should refer to
  /// at least `roaring_bitmap_size_in_bytes(r)` allocated bytes.
  ///
  /// See `roaring_bitmap_portable_serialize()` if you want a format that's
  /// compatible with Java and Go implementations.  This format can sometimes be
  /// more space efficient than the portable form, e.g. when the data is sparse.
  ///
  /// Returns how many bytes written, should be `roaring_bitmap_size_in_bytes(r)`.
  ///
  /// This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),
  /// the data format is going to be big-endian and not compatible with little-endian systems.
  int roaring_bitmap_serialize(
    ffi.Pointer<roaring_bitmap_t> r,
    ffi.Pointer<ffi.Char> buf,
  ) {
    return _roaring_bitmap_serialize(
      r,
      buf,
    );
  }

  late final _roaring_bitmap_serializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<ffi.Char>)>>('roaring_bitmap_serialize');
  late final _roaring_bitmap_serialize =
      _roaring_bitmap_serializePtr.asFunction<
          int Function(ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<ffi.Char>)>();

  /// Use with `roaring_bitmap_serialize()`.
  ///
  /// (See `roaring_bitmap_portable_deserialize()` if you want a format that's
  /// compatible with Java and Go implementations).
  ///
  /// This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),
  /// the data format is going to be big-endian and not compatible with little-endian systems.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_deserialize(
    ffi.Pointer<ffi.Void> buf,
  ) {
    return _roaring_bitmap_deserialize(
      buf,
    );
  }

  late final _roaring_bitmap_deserializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(
              ffi.Pointer<ffi.Void>)>>('roaring_bitmap_deserialize');
  late final _roaring_bitmap_deserialize =
      _roaring_bitmap_deserializePtr.asFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<ffi.Void>)>();

  /// Use with `roaring_bitmap_serialize()`.
  ///
  /// (See `roaring_bitmap_portable_deserialize_safe()` if you want a format that's
  /// compatible with Java and Go implementations).
  ///
  /// This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),
  /// the data format is going to be big-endian and not compatible with little-endian systems.
  ///
  /// The difference with `roaring_bitmap_deserialize()` is that this function checks that the input buffer
  /// is a valid bitmap.  If the buffer is too small, NULL is returned.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_deserialize_safe(
    ffi.Pointer<ffi.Void> buf,
    int maxbytes,
  ) {
    return _roaring_bitmap_deserialize_safe(
      buf,
      maxbytes,
    );
  }

  late final _roaring_bitmap_deserialize_safePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<ffi.Void>,
              ffi.Size)>>('roaring_bitmap_deserialize_safe');
  late final _roaring_bitmap_deserialize_safe =
      _roaring_bitmap_deserialize_safePtr.asFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<ffi.Void>, int)>();

  /// How many bytes are required to serialize this bitmap (NOT compatible
  /// with Java and Go versions)
  int roaring_bitmap_size_in_bytes(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_size_in_bytes(
      r,
    );
  }

  late final _roaring_bitmap_size_in_bytesPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_size_in_bytes');
  late final _roaring_bitmap_size_in_bytes = _roaring_bitmap_size_in_bytesPtr
      .asFunction<int Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Read bitmap from a serialized buffer.
  /// In case of failure, NULL is returned.
  ///
  /// This function is unsafe in the sense that if there is no valid serialized
  /// bitmap at the pointer, then many bytes could be read, possibly causing a
  /// buffer overflow.  See also roaring_bitmap_portable_deserialize_safe().
  ///
  /// This is meant to be compatible with the Java and Go versions:
  /// https://github.com/RoaringBitmap/RoaringFormatSpec
  ///
  /// This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),
  /// the data format is going to be big-endian and not compatible with little-endian systems.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_portable_deserialize(
    ffi.Pointer<ffi.Char> buf,
  ) {
    return _roaring_bitmap_portable_deserialize(
      buf,
    );
  }

  late final _roaring_bitmap_portable_deserializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(
              ffi.Pointer<ffi.Char>)>>('roaring_bitmap_portable_deserialize');
  late final _roaring_bitmap_portable_deserialize =
      _roaring_bitmap_portable_deserializePtr.asFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<ffi.Char>)>();

  /// Read bitmap from a serialized buffer safely (reading up to maxbytes).
  /// In case of failure, NULL is returned.
  ///
  /// This is meant to be compatible with the Java and Go versions:
  /// https://github.com/RoaringBitmap/RoaringFormatSpec
  ///
  /// The function itself is safe in the sense that it will not cause buffer overflows.
  /// However, for correct operations, it is assumed that the bitmap read was once
  /// serialized from a valid bitmap (i.e., it follows the format specification).
  /// If you provided an incorrect input (garbage), then the bitmap read may not be in
  /// a valid state and following operations may not lead to sensible results.
  /// In particular, the serialized array containers need to be in sorted order, and the
  /// run containers should be in sorted non-overlapping order. This is is guaranteed to
  /// happen when serializing an existing bitmap, but not for random inputs.
  ///
  /// This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),
  /// the data format is going to be big-endian and not compatible with little-endian systems.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_portable_deserialize_safe(
    ffi.Pointer<ffi.Char> buf,
    int maxbytes,
  ) {
    return _roaring_bitmap_portable_deserialize_safe(
      buf,
      maxbytes,
    );
  }

  late final _roaring_bitmap_portable_deserialize_safePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<ffi.Char>,
              ffi.Size)>>('roaring_bitmap_portable_deserialize_safe');
  late final _roaring_bitmap_portable_deserialize_safe =
      _roaring_bitmap_portable_deserialize_safePtr.asFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Read bitmap from a serialized buffer.
  /// In case of failure, NULL is returned.
  ///
  /// Bitmap returned by this function can be used in all readonly contexts.
  /// Bitmap must be freed as usual, by calling roaring_bitmap_free().
  /// Underlying buffer must not be freed or modified while it backs any bitmaps.
  ///
  /// The function is unsafe in the following ways:
  /// 1) It may execute unaligned memory accesses.
  /// 2) A buffer overflow may occur if buf does not point to a valid serialized
  /// bitmap.
  ///
  /// This is meant to be compatible with the Java and Go versions:
  /// https://github.com/RoaringBitmap/RoaringFormatSpec
  ///
  /// This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),
  /// the data format is going to be big-endian and not compatible with little-endian systems.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_portable_deserialize_frozen(
    ffi.Pointer<ffi.Char> buf,
  ) {
    return _roaring_bitmap_portable_deserialize_frozen(
      buf,
    );
  }

  late final _roaring_bitmap_portable_deserialize_frozenPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<ffi.Char>)>>(
      'roaring_bitmap_portable_deserialize_frozen');
  late final _roaring_bitmap_portable_deserialize_frozen =
      _roaring_bitmap_portable_deserialize_frozenPtr.asFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<ffi.Char>)>();

  /// Check how many bytes would be read (up to maxbytes) at this pointer if there
  /// is a bitmap, returns zero if there is no valid bitmap.
  ///
  /// This is meant to be compatible with the Java and Go versions:
  /// https://github.com/RoaringBitmap/RoaringFormatSpec
  int roaring_bitmap_portable_deserialize_size(
    ffi.Pointer<ffi.Char> buf,
    int maxbytes,
  ) {
    return _roaring_bitmap_portable_deserialize_size(
      buf,
      maxbytes,
    );
  }

  late final _roaring_bitmap_portable_deserialize_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>,
              ffi.Size)>>('roaring_bitmap_portable_deserialize_size');
  late final _roaring_bitmap_portable_deserialize_size =
      _roaring_bitmap_portable_deserialize_sizePtr
          .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// How many bytes are required to serialize this bitmap.
  ///
  /// This is meant to be compatible with the Java and Go versions:
  /// https://github.com/RoaringBitmap/RoaringFormatSpec
  int roaring_bitmap_portable_size_in_bytes(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_portable_size_in_bytes(
      r,
    );
  }

  late final _roaring_bitmap_portable_size_in_bytesPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_portable_size_in_bytes');
  late final _roaring_bitmap_portable_size_in_bytes =
      _roaring_bitmap_portable_size_in_bytesPtr
          .asFunction<int Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Write a bitmap to a char buffer.  The output buffer should refer to at least
  /// `roaring_bitmap_portable_size_in_bytes(r)` bytes of allocated memory.
  ///
  /// Returns how many bytes were written which should match
  /// `roaring_bitmap_portable_size_in_bytes(r)`.
  ///
  /// This is meant to be compatible with the Java and Go versions:
  /// https://github.com/RoaringBitmap/RoaringFormatSpec
  ///
  /// This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),
  /// the data format is going to be big-endian and not compatible with little-endian systems.
  int roaring_bitmap_portable_serialize(
    ffi.Pointer<roaring_bitmap_t> r,
    ffi.Pointer<ffi.Char> buf,
  ) {
    return _roaring_bitmap_portable_serialize(
      r,
      buf,
    );
  }

  late final _roaring_bitmap_portable_serializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<ffi.Char>)>>('roaring_bitmap_portable_serialize');
  late final _roaring_bitmap_portable_serialize =
      _roaring_bitmap_portable_serializePtr.asFunction<
          int Function(ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<ffi.Char>)>();

  /// Returns number of bytes required to serialize bitmap using frozen format.
  int roaring_bitmap_frozen_size_in_bytes(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_frozen_size_in_bytes(
      r,
    );
  }

  late final _roaring_bitmap_frozen_size_in_bytesPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_frozen_size_in_bytes');
  late final _roaring_bitmap_frozen_size_in_bytes =
      _roaring_bitmap_frozen_size_in_bytesPtr
          .asFunction<int Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Serializes bitmap using frozen format.
  /// Buffer size must be at least roaring_bitmap_frozen_size_in_bytes().
  ///
  /// This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),
  /// the data format is going to be big-endian and not compatible with little-endian systems.
  void roaring_bitmap_frozen_serialize(
    ffi.Pointer<roaring_bitmap_t> r,
    ffi.Pointer<ffi.Char> buf,
  ) {
    return _roaring_bitmap_frozen_serialize(
      r,
      buf,
    );
  }

  late final _roaring_bitmap_frozen_serializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<ffi.Char>)>>('roaring_bitmap_frozen_serialize');
  late final _roaring_bitmap_frozen_serialize =
      _roaring_bitmap_frozen_serializePtr.asFunction<
          void Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<ffi.Char>)>();

  /// Creates constant bitmap that is a view of a given buffer.
  /// Buffer data should have been written by `roaring_bitmap_frozen_serialize()`
  /// Its beginning must also be aligned by 32 bytes.
  /// Length must be equal exactly to `roaring_bitmap_frozen_size_in_bytes()`.
  /// In case of failure, NULL is returned.
  ///
  /// Bitmap returned by this function can be used in all readonly contexts.
  /// Bitmap must be freed as usual, by calling roaring_bitmap_free().
  /// Underlying buffer must not be freed or modified while it backs any bitmaps.
  ///
  /// This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),
  /// the data format is going to be big-endian and not compatible with little-endian systems.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_frozen_view(
    ffi.Pointer<ffi.Char> buf,
    int length,
  ) {
    return _roaring_bitmap_frozen_view(
      buf,
      length,
    );
  }

  late final _roaring_bitmap_frozen_viewPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('roaring_bitmap_frozen_view');
  late final _roaring_bitmap_frozen_view =
      _roaring_bitmap_frozen_viewPtr.asFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Iterate over the bitmap elements. The function iterator is called once for
  /// all the values with ptr (can be NULL) as the second parameter of each call.
  ///
  /// `roaring_iterator` is simply a pointer to a function that returns bool
  /// (true means that the iteration should continue while false means that it
  /// should stop), and takes (uint32_t,void*) as inputs.
  ///
  /// Returns true if the roaring_iterator returned true throughout (so that all
  /// data points were necessarily visited).
  ///
  /// Iteration is ordered: from the smallest to the largest elements.
  bool roaring_iterate(
    ffi.Pointer<roaring_bitmap_t> r,
    roaring_iterator iterator,
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _roaring_iterate(
      r,
      iterator,
      ptr,
    );
  }

  late final _roaring_iteratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>, roaring_iterator,
              ffi.Pointer<ffi.Void>)>>('roaring_iterate');
  late final _roaring_iterate = _roaring_iteratePtr.asFunction<
      bool Function(ffi.Pointer<roaring_bitmap_t>, roaring_iterator,
          ffi.Pointer<ffi.Void>)>();

  bool roaring_iterate64(
    ffi.Pointer<roaring_bitmap_t> r,
    roaring_iterator64 iterator,
    int high_bits,
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _roaring_iterate64(
      r,
      iterator,
      high_bits,
      ptr,
    );
  }

  late final _roaring_iterate64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>, roaring_iterator64,
              ffi.Uint64, ffi.Pointer<ffi.Void>)>>('roaring_iterate64');
  late final _roaring_iterate64 = _roaring_iterate64Ptr.asFunction<
      bool Function(ffi.Pointer<roaring_bitmap_t>, roaring_iterator64, int,
          ffi.Pointer<ffi.Void>)>();

  /// Return true if the two bitmaps contain the same elements.
  bool roaring_bitmap_equals(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_equals(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_equalsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_equals');
  late final _roaring_bitmap_equals = _roaring_bitmap_equalsPtr.asFunction<
      bool Function(
          ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Return true if all the elements of r1 are also in r2.
  bool roaring_bitmap_is_subset(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_is_subset(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_is_subsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_is_subset');
  late final _roaring_bitmap_is_subset =
      _roaring_bitmap_is_subsetPtr.asFunction<
          bool Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Return true if all the elements of r1 are also in r2, and r2 is strictly
  /// greater than r1.
  bool roaring_bitmap_is_strict_subset(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_is_strict_subset(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_is_strict_subsetPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>,
                  ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_is_strict_subset');
  late final _roaring_bitmap_is_strict_subset =
      _roaring_bitmap_is_strict_subsetPtr.asFunction<
          bool Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// (For expert users who seek high performance.)
  ///
  /// Computes the union between two bitmaps and returns new bitmap. The caller is
  /// responsible for memory management.
  ///
  /// The lazy version defers some computations such as the maintenance of the
  /// cardinality counts. Thus you must call `roaring_bitmap_repair_after_lazy()`
  /// after executing "lazy" computations.
  ///
  /// It is safe to repeatedly call roaring_bitmap_lazy_or_inplace on the result.
  ///
  /// `bitsetconversion` is a flag which determines whether container-container
  /// operations force a bitset conversion.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_lazy_or(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
    bool bitsetconversion,
  ) {
    return _roaring_bitmap_lazy_or(
      r1,
      r2,
      bitsetconversion,
    );
  }

  late final _roaring_bitmap_lazy_orPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(
              ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>,
              ffi.Bool)>>('roaring_bitmap_lazy_or');
  late final _roaring_bitmap_lazy_or = _roaring_bitmap_lazy_orPtr.asFunction<
      ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<roaring_bitmap_t>,
          ffi.Pointer<roaring_bitmap_t>, bool)>();

  /// (For expert users who seek high performance.)
  ///
  /// Inplace version of roaring_bitmap_lazy_or, modifies r1.
  ///
  /// `bitsetconversion` is a flag which determines whether container-container
  /// operations force a bitset conversion.
  void roaring_bitmap_lazy_or_inplace(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
    bool bitsetconversion,
  ) {
    return _roaring_bitmap_lazy_or_inplace(
      r1,
      r2,
      bitsetconversion,
    );
  }

  late final _roaring_bitmap_lazy_or_inplacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>,
              ffi.Bool)>>('roaring_bitmap_lazy_or_inplace');
  late final _roaring_bitmap_lazy_or_inplace =
      _roaring_bitmap_lazy_or_inplacePtr.asFunction<
          void Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>, bool)>();

  /// (For expert users who seek high performance.)
  ///
  /// Execute maintenance on a bitmap created from `roaring_bitmap_lazy_or()`
  /// or modified with `roaring_bitmap_lazy_or_inplace()`.
  void roaring_bitmap_repair_after_lazy(
    ffi.Pointer<roaring_bitmap_t> r1,
  ) {
    return _roaring_bitmap_repair_after_lazy(
      r1,
    );
  }

  late final _roaring_bitmap_repair_after_lazyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_repair_after_lazy');
  late final _roaring_bitmap_repair_after_lazy =
      _roaring_bitmap_repair_after_lazyPtr
          .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Computes the symmetric difference between two bitmaps and returns new bitmap.
  /// The caller is responsible for memory management.
  ///
  /// The lazy version defers some computations such as the maintenance of the
  /// cardinality counts. Thus you must call `roaring_bitmap_repair_after_lazy()`
  /// after executing "lazy" computations.
  ///
  /// It is safe to repeatedly call `roaring_bitmap_lazy_xor_inplace()` on
  /// the result.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_lazy_xor(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_lazy_xor(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_lazy_xorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_lazy_xor');
  late final _roaring_bitmap_lazy_xor = _roaring_bitmap_lazy_xorPtr.asFunction<
      ffi.Pointer<roaring_bitmap_t> Function(
          ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// (For expert users who seek high performance.)
  ///
  /// Inplace version of roaring_bitmap_lazy_xor, modifies r1. r1 != r2
  void roaring_bitmap_lazy_xor_inplace(
    ffi.Pointer<roaring_bitmap_t> r1,
    ffi.Pointer<roaring_bitmap_t> r2,
  ) {
    return _roaring_bitmap_lazy_xor_inplace(
      r1,
      r2,
    );
  }

  late final _roaring_bitmap_lazy_xor_inplacePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<roaring_bitmap_t>,
                  ffi.Pointer<roaring_bitmap_t>)>>(
      'roaring_bitmap_lazy_xor_inplace');
  late final _roaring_bitmap_lazy_xor_inplace =
      _roaring_bitmap_lazy_xor_inplacePtr.asFunction<
          void Function(
              ffi.Pointer<roaring_bitmap_t>, ffi.Pointer<roaring_bitmap_t>)>();

  /// Compute the negation of the bitmap in the interval [range_start, range_end).
  /// The number of negated values is range_end - range_start.
  /// Areas outside the range are passed through unchanged.
  ffi.Pointer<roaring_bitmap_t> roaring_bitmap_flip(
    ffi.Pointer<roaring_bitmap_t> r1,
    int range_start,
    int range_end,
  ) {
    return _roaring_bitmap_flip(
      r1,
      range_start,
      range_end,
    );
  }

  late final _roaring_bitmap_flipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_bitmap_t> Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Uint64, ffi.Uint64)>>('roaring_bitmap_flip');
  late final _roaring_bitmap_flip = _roaring_bitmap_flipPtr.asFunction<
      ffi.Pointer<roaring_bitmap_t> Function(
          ffi.Pointer<roaring_bitmap_t>, int, int)>();

  /// compute (in place) the negation of the roaring bitmap within a specified
  /// interval: [range_start, range_end). The number of negated values is
  /// range_end - range_start.
  /// Areas outside the range are passed through unchanged.
  void roaring_bitmap_flip_inplace(
    ffi.Pointer<roaring_bitmap_t> r1,
    int range_start,
    int range_end,
  ) {
    return _roaring_bitmap_flip_inplace(
      r1,
      range_start,
      range_end,
    );
  }

  late final _roaring_bitmap_flip_inplacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>, ffi.Uint64,
              ffi.Uint64)>>('roaring_bitmap_flip_inplace');
  late final _roaring_bitmap_flip_inplace = _roaring_bitmap_flip_inplacePtr
      .asFunction<void Function(ffi.Pointer<roaring_bitmap_t>, int, int)>();

  /// Selects the element at index 'rank' where the smallest element is at index 0.
  /// If the size of the roaring bitmap is strictly greater than rank, then this
  /// function returns true and sets element to the element of given rank.
  /// Otherwise, it returns false.
  bool roaring_bitmap_select(
    ffi.Pointer<roaring_bitmap_t> r,
    int rank,
    ffi.Pointer<ffi.Uint32> element,
  ) {
    return _roaring_bitmap_select(
      r,
      rank,
      element,
    );
  }

  late final _roaring_bitmap_selectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_bitmap_t>, ffi.Uint32,
              ffi.Pointer<ffi.Uint32>)>>('roaring_bitmap_select');
  late final _roaring_bitmap_select = _roaring_bitmap_selectPtr.asFunction<
      bool Function(
          ffi.Pointer<roaring_bitmap_t>, int, ffi.Pointer<ffi.Uint32>)>();

  /// roaring_bitmap_rank returns the number of integers that are smaller or equal
  /// to x. Thus if x is the first element, this function will return 1. If
  /// x is smaller than the smallest element, this function will return 0.
  ///
  /// The indexing convention differs between roaring_bitmap_select and
  /// roaring_bitmap_rank: roaring_bitmap_select refers to the smallest value
  /// as having index 0, whereas roaring_bitmap_rank returns 1 when ranking
  /// the smallest value.
  int roaring_bitmap_rank(
    ffi.Pointer<roaring_bitmap_t> r,
    int x,
  ) {
    return _roaring_bitmap_rank(
      r,
      x,
    );
  }

  late final _roaring_bitmap_rankPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Uint32)>>('roaring_bitmap_rank');
  late final _roaring_bitmap_rank = _roaring_bitmap_rankPtr
      .asFunction<int Function(ffi.Pointer<roaring_bitmap_t>, int)>();

  /// Returns the index of x in the given roaring bitmap.
  /// If the roaring bitmap doesn't contain x , this function will return -1.
  /// The difference with rank function is that this function will return -1 when x
  /// is not the element of roaring bitmap, but the rank function will return a
  /// non-negative number.
  int roaring_bitmap_get_index(
    ffi.Pointer<roaring_bitmap_t> r,
    int x,
  ) {
    return _roaring_bitmap_get_index(
      r,
      x,
    );
  }

  late final _roaring_bitmap_get_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Uint32)>>('roaring_bitmap_get_index');
  late final _roaring_bitmap_get_index = _roaring_bitmap_get_indexPtr
      .asFunction<int Function(ffi.Pointer<roaring_bitmap_t>, int)>();

  /// Returns the smallest value in the set, or UINT32_MAX if the set is empty.
  int roaring_bitmap_minimum(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_minimum(
      r,
    );
  }

  late final _roaring_bitmap_minimumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_minimum');
  late final _roaring_bitmap_minimum = _roaring_bitmap_minimumPtr
      .asFunction<int Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// Returns the greatest value in the set, or 0 if the set is empty.
  int roaring_bitmap_maximum(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_bitmap_maximum(
      r,
    );
  }

  late final _roaring_bitmap_maximumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_bitmap_maximum');
  late final _roaring_bitmap_maximum = _roaring_bitmap_maximumPtr
      .asFunction<int Function(ffi.Pointer<roaring_bitmap_t>)>();

  /// (For advanced users.)
  ///
  /// Collect statistics about the bitmap, see roaring_types.h for
  /// a description of roaring_statistics_t
  void roaring_bitmap_statistics(
    ffi.Pointer<roaring_bitmap_t> r,
    ffi.Pointer<roaring_statistics_t> stat,
  ) {
    return _roaring_bitmap_statistics(
      r,
      stat,
    );
  }

  late final _roaring_bitmap_statisticsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_statistics_t>)>>('roaring_bitmap_statistics');
  late final _roaring_bitmap_statistics =
      _roaring_bitmap_statisticsPtr.asFunction<
          void Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_statistics_t>)>();

  /// Initialize an iterator object that can be used to iterate through the
  /// values. If there is a  value, then this iterator points to the first value
  /// and `it->has_value` is true. The value is in `it->current_value`.
  void roaring_init_iterator(
    ffi.Pointer<roaring_bitmap_t> r,
    ffi.Pointer<roaring_uint32_iterator_t> newit,
  ) {
    return _roaring_init_iterator(
      r,
      newit,
    );
  }

  late final _roaring_init_iteratorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<roaring_bitmap_t>,
                  ffi.Pointer<roaring_uint32_iterator_t>)>>(
      'roaring_init_iterator');
  late final _roaring_init_iterator = _roaring_init_iteratorPtr.asFunction<
      void Function(ffi.Pointer<roaring_bitmap_t>,
          ffi.Pointer<roaring_uint32_iterator_t>)>();

  /// Initialize an iterator object that can be used to iterate through the
  /// values. If there is a value, then this iterator points to the last value
  /// and `it->has_value` is true. The value is in `it->current_value`.
  void roaring_init_iterator_last(
    ffi.Pointer<roaring_bitmap_t> r,
    ffi.Pointer<roaring_uint32_iterator_t> newit,
  ) {
    return _roaring_init_iterator_last(
      r,
      newit,
    );
  }

  late final _roaring_init_iterator_lastPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<roaring_bitmap_t>,
                  ffi.Pointer<roaring_uint32_iterator_t>)>>(
      'roaring_init_iterator_last');
  late final _roaring_init_iterator_last =
      _roaring_init_iterator_lastPtr.asFunction<
          void Function(ffi.Pointer<roaring_bitmap_t>,
              ffi.Pointer<roaring_uint32_iterator_t>)>();

  /// Create an iterator object that can be used to iterate through the values.
  /// Caller is responsible for calling `roaring_free_iterator()`.
  ///
  /// The iterator is initialized (this function calls `roaring_init_iterator()`)
  /// If there is a value, then this iterator points to the first value and
  /// `it->has_value` is true.  The value is in `it->current_value`.
  ffi.Pointer<roaring_uint32_iterator_t> roaring_create_iterator(
    ffi.Pointer<roaring_bitmap_t> r,
  ) {
    return _roaring_create_iterator(
      r,
    );
  }

  late final _roaring_create_iteratorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<roaring_uint32_iterator_t> Function(
              ffi.Pointer<roaring_bitmap_t>)>>('roaring_create_iterator');
  late final _roaring_create_iterator = _roaring_create_iteratorPtr.asFunction<
      ffi.Pointer<roaring_uint32_iterator_t> Function(
          ffi.Pointer<roaring_bitmap_t>)>();

  /// Advance the iterator. If there is a new value, then `it->has_value` is true.
  /// The new value is in `it->current_value`. Values are traversed in increasing
  /// orders. For convenience, returns `it->has_value`.
  bool roaring_advance_uint32_iterator(
    ffi.Pointer<roaring_uint32_iterator_t> it,
  ) {
    return _roaring_advance_uint32_iterator(
      it,
    );
  }

  late final _roaring_advance_uint32_iteratorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<roaring_uint32_iterator_t>)>>(
      'roaring_advance_uint32_iterator');
  late final _roaring_advance_uint32_iterator =
      _roaring_advance_uint32_iteratorPtr
          .asFunction<bool Function(ffi.Pointer<roaring_uint32_iterator_t>)>();

  /// Decrement the iterator. If there's a new value, then `it->has_value` is true.
  /// The new value is in `it->current_value`. Values are traversed in decreasing
  /// order. For convenience, returns `it->has_value`.
  bool roaring_previous_uint32_iterator(
    ffi.Pointer<roaring_uint32_iterator_t> it,
  ) {
    return _roaring_previous_uint32_iterator(
      it,
    );
  }

  late final _roaring_previous_uint32_iteratorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<roaring_uint32_iterator_t>)>>(
      'roaring_previous_uint32_iterator');
  late final _roaring_previous_uint32_iterator =
      _roaring_previous_uint32_iteratorPtr
          .asFunction<bool Function(ffi.Pointer<roaring_uint32_iterator_t>)>();

  /// Move the iterator to the first value >= `val`. If there is a such a value,
  /// then `it->has_value` is true. The new value is in `it->current_value`.
  /// For convenience, returns `it->has_value`.
  bool roaring_move_uint32_iterator_equalorlarger(
    ffi.Pointer<roaring_uint32_iterator_t> it,
    int val,
  ) {
    return _roaring_move_uint32_iterator_equalorlarger(
      it,
      val,
    );
  }

  late final _roaring_move_uint32_iterator_equalorlargerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<roaring_uint32_iterator_t>,
              ffi.Uint32)>>('roaring_move_uint32_iterator_equalorlarger');
  late final _roaring_move_uint32_iterator_equalorlarger =
      _roaring_move_uint32_iterator_equalorlargerPtr.asFunction<
          bool Function(ffi.Pointer<roaring_uint32_iterator_t>, int)>();

  /// Creates a copy of an iterator.
  /// Caller must free it.
  ffi.Pointer<roaring_uint32_iterator_t> roaring_copy_uint32_iterator(
    ffi.Pointer<roaring_uint32_iterator_t> it,
  ) {
    return _roaring_copy_uint32_iterator(
      it,
    );
  }

  late final _roaring_copy_uint32_iteratorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<roaring_uint32_iterator_t> Function(
                  ffi.Pointer<roaring_uint32_iterator_t>)>>(
      'roaring_copy_uint32_iterator');
  late final _roaring_copy_uint32_iterator =
      _roaring_copy_uint32_iteratorPtr.asFunction<
          ffi.Pointer<roaring_uint32_iterator_t> Function(
              ffi.Pointer<roaring_uint32_iterator_t>)>();

  /// Free memory following `roaring_create_iterator()`
  void roaring_free_uint32_iterator(
    ffi.Pointer<roaring_uint32_iterator_t> it,
  ) {
    return _roaring_free_uint32_iterator(
      it,
    );
  }

  late final _roaring_free_uint32_iteratorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<roaring_uint32_iterator_t>)>>(
      'roaring_free_uint32_iterator');
  late final _roaring_free_uint32_iterator = _roaring_free_uint32_iteratorPtr
      .asFunction<void Function(ffi.Pointer<roaring_uint32_iterator_t>)>();

  int roaring_read_uint32_iterator(
    ffi.Pointer<roaring_uint32_iterator_t> it,
    ffi.Pointer<ffi.Uint32> buf,
    int count,
  ) {
    return _roaring_read_uint32_iterator(
      it,
      buf,
      count,
    );
  }

  late final _roaring_read_uint32_iteratorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<roaring_uint32_iterator_t>,
              ffi.Pointer<ffi.Uint32>,
              ffi.Uint32)>>('roaring_read_uint32_iterator');
  late final _roaring_read_uint32_iterator =
      _roaring_read_uint32_iteratorPtr.asFunction<
          int Function(ffi.Pointer<roaring_uint32_iterator_t>,
              ffi.Pointer<ffi.Uint32>, int)>();

  void roaring_init_memory_hook(
    roaring_memory_t memory_hook,
  ) {
    return _roaring_init_memory_hook(
      memory_hook,
    );
  }

  late final _roaring_init_memory_hookPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(roaring_memory_t)>>(
          'roaring_init_memory_hook');
  late final _roaring_init_memory_hook = _roaring_init_memory_hookPtr
      .asFunction<void Function(roaring_memory_t)>();

  ffi.Pointer<ffi.Void> roaring_malloc(
    int arg0,
  ) {
    return _roaring_malloc(
      arg0,
    );
  }

  late final _roaring_mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'roaring_malloc');
  late final _roaring_malloc =
      _roaring_mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> roaring_realloc(
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    return _roaring_realloc(
      arg0,
      arg1,
    );
  }

  late final _roaring_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('roaring_realloc');
  late final _roaring_realloc = _roaring_reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> roaring_calloc(
    int arg0,
    int arg1,
  ) {
    return _roaring_calloc(
      arg0,
      arg1,
    );
  }

  late final _roaring_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, ffi.Size)>>('roaring_calloc');
  late final _roaring_calloc =
      _roaring_callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void roaring_free(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _roaring_free(
      arg0,
    );
  }

  late final _roaring_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'roaring_free');
  late final _roaring_free =
      _roaring_freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> roaring_aligned_malloc(
    int arg0,
    int arg1,
  ) {
    return _roaring_aligned_malloc(
      arg0,
      arg1,
    );
  }

  late final _roaring_aligned_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, ffi.Size)>>('roaring_aligned_malloc');
  late final _roaring_aligned_malloc = _roaring_aligned_mallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void roaring_aligned_free(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _roaring_aligned_free(
      arg0,
    );
  }

  late final _roaring_aligned_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'roaring_aligned_free');
  late final _roaring_aligned_free = _roaring_aligned_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
}

class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

/// Roaring arrays are array-based key-value pairs having containers as values
/// and 16-bit integer keys. A roaring bitmap  might be implemented as such.
class roaring_array_s extends ffi.Struct {
  @ffi.Int32()
  external int size;

  @ffi.Int32()
  external int allocation_size;

  external ffi.Pointer<ffi.Pointer<ffi.Void>> containers;

  external ffi.Pointer<ffi.Uint16> keys;

  external ffi.Pointer<ffi.Uint8> typecodes;

  @ffi.Uint8()
  external int flags;
}

/// (For advanced users.)
/// The roaring_statistics_t can be used to collect detailed statistics about
/// the composition of a roaring bitmap.
class roaring_statistics_s extends ffi.Struct {
  @ffi.Uint32()
  external int n_containers;

  @ffi.Uint32()
  external int n_array_containers;

  @ffi.Uint32()
  external int n_run_containers;

  @ffi.Uint32()
  external int n_bitset_containers;

  @ffi.Uint32()
  external int n_values_array_containers;

  @ffi.Uint32()
  external int n_values_run_containers;

  @ffi.Uint32()
  external int n_values_bitset_containers;

  @ffi.Uint32()
  external int n_bytes_array_containers;

  @ffi.Uint32()
  external int n_bytes_run_containers;

  @ffi.Uint32()
  external int n_bytes_bitset_containers;

  @ffi.Uint32()
  external int max_value;

  @ffi.Uint32()
  external int min_value;

  @ffi.Uint64()
  external int sum_value;

  @ffi.Uint64()
  external int cardinality;
}

abstract class idtype_t {
  static const int P_ALL = 0;
  static const int P_PID = 1;
  static const int P_PGID = 2;
}

class __darwin_arm_exception_state extends ffi.Struct {
  @__uint32_t()
  external int __exception;

  @__uint32_t()
  external int __fsr;

  @__uint32_t()
  external int __far;
}

typedef __uint32_t = ffi.UnsignedInt;

class __darwin_arm_exception_state64 extends ffi.Struct {
  @__uint64_t()
  external int __far;

  @__uint32_t()
  external int __esr;

  @__uint32_t()
  external int __exception;
}

typedef __uint64_t = ffi.UnsignedLongLong;

class __darwin_arm_thread_state extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __sp;

  @__uint32_t()
  external int __lr;

  @__uint32_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;
}

class __darwin_arm_thread_state64 extends ffi.Struct {
  @ffi.Array.multi([29])
  external ffi.Array<__uint64_t> __x;

  @__uint64_t()
  external int __fp;

  @__uint64_t()
  external int __lr;

  @__uint64_t()
  external int __sp;

  @__uint64_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;

  @__uint32_t()
  external int __pad;
}

class __darwin_arm_vfp_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __fpscr;
}

class __darwin_arm_neon_state64 extends ffi.Opaque {}

class __darwin_arm_neon_state extends ffi.Opaque {}

class __arm_pagein_state extends ffi.Struct {
  @ffi.Int()
  external int __pagein_error;
}

class __arm_legacy_debug_state extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;
}

class __darwin_arm_debug_state32 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

class __darwin_arm_debug_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

class __darwin_arm_cpmu_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __ctrs;
}

class __darwin_mcontext32 extends ffi.Struct {
  external __darwin_arm_exception_state __es;

  external __darwin_arm_thread_state __ss;

  external __darwin_arm_vfp_state __fs;
}

class __darwin_mcontext64 extends ffi.Opaque {}

class __darwin_sigaltstack extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ss_sp;

  @__darwin_size_t()
  external int ss_size;

  @ffi.Int()
  external int ss_flags;
}

typedef __darwin_size_t = ffi.UnsignedLong;

class __darwin_ucontext extends ffi.Opaque {}

class sigval extends ffi.Union {
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

class sigevent extends ffi.Struct {
  @ffi.Int()
  external int sigev_notify;

  @ffi.Int()
  external int sigev_signo;

  external sigval sigev_value;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sigval)>>
      sigev_notify_function;

  external ffi.Pointer<pthread_attr_t> sigev_notify_attributes;
}

typedef pthread_attr_t = __darwin_pthread_attr_t;
typedef __darwin_pthread_attr_t = _opaque_pthread_attr_t;

class __siginfo extends ffi.Struct {
  @ffi.Int()
  external int si_signo;

  @ffi.Int()
  external int si_errno;

  @ffi.Int()
  external int si_code;

  @pid_t()
  external int si_pid;

  @uid_t()
  external int si_uid;

  @ffi.Int()
  external int si_status;

  external ffi.Pointer<ffi.Void> si_addr;

  external sigval si_value;

  @ffi.Long()
  external int si_band;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedLong> __pad;
}

typedef pid_t = __darwin_pid_t;
typedef __darwin_pid_t = __int32_t;
typedef __int32_t = ffi.Int;
typedef uid_t = __darwin_uid_t;
typedef __darwin_uid_t = __uint32_t;

class __sigaction_u extends ffi.Union {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      __sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int, ffi.Pointer<__siginfo>, ffi.Pointer<ffi.Void>)>>
      __sa_sigaction;
}

class __sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u1;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Void>)>> sa_tramp;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

typedef siginfo_t = __siginfo;
typedef sigset_t = __darwin_sigset_t;
typedef __darwin_sigset_t = __uint32_t;

class sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u1;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

class sigstack extends ffi.Struct {
  external ffi.Pointer<ffi.Char> ss_sp;

  @ffi.Int()
  external int ss_onstack;
}

class timeval extends ffi.Struct {
  @__darwin_time_t()
  external int tv_sec;

  @__darwin_suseconds_t()
  external int tv_usec;
}

typedef __darwin_time_t = ffi.Long;
typedef __darwin_suseconds_t = __int32_t;

class rusage extends ffi.Struct {
  external timeval ru_utime;

  external timeval ru_stime;

  @ffi.Long()
  external int ru_maxrss;

  @ffi.Long()
  external int ru_ixrss;

  @ffi.Long()
  external int ru_idrss;

  @ffi.Long()
  external int ru_isrss;

  @ffi.Long()
  external int ru_minflt;

  @ffi.Long()
  external int ru_majflt;

  @ffi.Long()
  external int ru_nswap;

  @ffi.Long()
  external int ru_inblock;

  @ffi.Long()
  external int ru_oublock;

  @ffi.Long()
  external int ru_msgsnd;

  @ffi.Long()
  external int ru_msgrcv;

  @ffi.Long()
  external int ru_nsignals;

  @ffi.Long()
  external int ru_nvcsw;

  @ffi.Long()
  external int ru_nivcsw;
}

class rusage_info_v0 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;
}

class rusage_info_v1 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;
}

class rusage_info_v2 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;
}

class rusage_info_v3 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;
}

class rusage_info_v4 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;
}

class rusage_info_v5 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;
}

class rusage_info_v6 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;

  @ffi.Uint64()
  external int ri_user_ptime;

  @ffi.Uint64()
  external int ri_system_ptime;

  @ffi.Uint64()
  external int ri_pinstructions;

  @ffi.Uint64()
  external int ri_pcycles;

  @ffi.Uint64()
  external int ri_energy_nj;

  @ffi.Uint64()
  external int ri_penergy_nj;

  @ffi.Array.multi([14])
  external ffi.Array<ffi.Uint64> ri_reserved;
}

class rlimit extends ffi.Struct {
  @rlim_t()
  external int rlim_cur;

  @rlim_t()
  external int rlim_max;
}

typedef rlim_t = __uint64_t;

class proc_rlimit_control_wakeupmon extends ffi.Struct {
  @ffi.Uint32()
  external int wm_flags;

  @ffi.Int32()
  external int wm_rate;
}

typedef id_t = __darwin_id_t;
typedef __darwin_id_t = __uint32_t;

class div_t extends ffi.Struct {
  @ffi.Int()
  external int quot;

  @ffi.Int()
  external int rem;
}

class ldiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

class int8x8x2_t extends ffi.Opaque {}

class int8x16x2_t extends ffi.Opaque {}

class int16x4x2_t extends ffi.Opaque {}

class int16x8x2_t extends ffi.Opaque {}

class int32x2x2_t extends ffi.Opaque {}

class int32x4x2_t extends ffi.Opaque {}

class int64x1x2_t extends ffi.Opaque {}

class int64x2x2_t extends ffi.Opaque {}

class uint8x8x2_t extends ffi.Opaque {}

class uint8x16x2_t extends ffi.Opaque {}

class uint16x4x2_t extends ffi.Opaque {}

class uint16x8x2_t extends ffi.Opaque {}

class uint32x2x2_t extends ffi.Opaque {}

class uint32x4x2_t extends ffi.Opaque {}

class uint64x1x2_t extends ffi.Opaque {}

class uint64x2x2_t extends ffi.Opaque {}

class float16x4x2_t extends ffi.Opaque {}

class float16x8x2_t extends ffi.Opaque {}

class float32x2x2_t extends ffi.Opaque {}

class float32x4x2_t extends ffi.Opaque {}

class float64x1x2_t extends ffi.Opaque {}

class float64x2x2_t extends ffi.Opaque {}

class poly8x8x2_t extends ffi.Opaque {}

class poly8x16x2_t extends ffi.Opaque {}

class poly16x4x2_t extends ffi.Opaque {}

class poly16x8x2_t extends ffi.Opaque {}

class poly64x1x2_t extends ffi.Opaque {}

class poly64x2x2_t extends ffi.Opaque {}

class int8x8x3_t extends ffi.Opaque {}

class int8x16x3_t extends ffi.Opaque {}

class int16x4x3_t extends ffi.Opaque {}

class int16x8x3_t extends ffi.Opaque {}

class int32x2x3_t extends ffi.Opaque {}

class int32x4x3_t extends ffi.Opaque {}

class int64x1x3_t extends ffi.Opaque {}

class int64x2x3_t extends ffi.Opaque {}

class uint8x8x3_t extends ffi.Opaque {}

class uint8x16x3_t extends ffi.Opaque {}

class uint16x4x3_t extends ffi.Opaque {}

class uint16x8x3_t extends ffi.Opaque {}

class uint32x2x3_t extends ffi.Opaque {}

class uint32x4x3_t extends ffi.Opaque {}

class uint64x1x3_t extends ffi.Opaque {}

class uint64x2x3_t extends ffi.Opaque {}

class float16x4x3_t extends ffi.Opaque {}

class float16x8x3_t extends ffi.Opaque {}

class float32x2x3_t extends ffi.Opaque {}

class float32x4x3_t extends ffi.Opaque {}

class float64x1x3_t extends ffi.Opaque {}

class float64x2x3_t extends ffi.Opaque {}

class poly8x8x3_t extends ffi.Opaque {}

class poly8x16x3_t extends ffi.Opaque {}

class poly16x4x3_t extends ffi.Opaque {}

class poly16x8x3_t extends ffi.Opaque {}

class poly64x1x3_t extends ffi.Opaque {}

class poly64x2x3_t extends ffi.Opaque {}

class int8x8x4_t extends ffi.Opaque {}

class int8x16x4_t extends ffi.Opaque {}

class int16x4x4_t extends ffi.Opaque {}

class int16x8x4_t extends ffi.Opaque {}

class int32x2x4_t extends ffi.Opaque {}

class int32x4x4_t extends ffi.Opaque {}

class int64x1x4_t extends ffi.Opaque {}

class int64x2x4_t extends ffi.Opaque {}

class uint8x8x4_t extends ffi.Opaque {}

class uint8x16x4_t extends ffi.Opaque {}

class uint16x4x4_t extends ffi.Opaque {}

class uint16x8x4_t extends ffi.Opaque {}

class uint32x2x4_t extends ffi.Opaque {}

class uint32x4x4_t extends ffi.Opaque {}

class uint64x1x4_t extends ffi.Opaque {}

class uint64x2x4_t extends ffi.Opaque {}

class float16x4x4_t extends ffi.Opaque {}

class float16x8x4_t extends ffi.Opaque {}

class float32x2x4_t extends ffi.Opaque {}

class float32x4x4_t extends ffi.Opaque {}

class float64x1x4_t extends ffi.Opaque {}

class float64x2x4_t extends ffi.Opaque {}

class poly8x8x4_t extends ffi.Opaque {}

class poly8x16x4_t extends ffi.Opaque {}

class poly16x4x4_t extends ffi.Opaque {}

class poly16x8x4_t extends ffi.Opaque {}

class poly64x1x4_t extends ffi.Opaque {}

class poly64x2x4_t extends ffi.Opaque {}

abstract class memory_order {
  static const int memory_order_relaxed = 0;
  static const int memory_order_consume = 1;
  static const int memory_order_acquire = 2;
  static const int memory_order_release = 3;
  static const int memory_order_acq_rel = 4;
  static const int memory_order_seq_cst = 5;
}

class atomic_flag extends ffi.Opaque {}

class __sbuf extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> _base;

  @ffi.Int()
  external int _size;
}

class __sFILEX extends ffi.Opaque {}

class __sFILE extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> _p;

  @ffi.Int()
  external int _r;

  @ffi.Int()
  external int _w;

  @ffi.Short()
  external int _flags;

  @ffi.Short()
  external int _file;

  external __sbuf _bf;

  @ffi.Int()
  external int _lbfsize;

  external ffi.Pointer<ffi.Void> _cookie;

  external ffi
          .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>
      _close;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _read;

  external ffi.Pointer<
      ffi.NativeFunction<
          fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>> _seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _write;

  external __sbuf _ub;

  external ffi.Pointer<__sFILEX> _extra;

  @ffi.Int()
  external int _ur;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedChar> _ubuf;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.UnsignedChar> _nbuf;

  external __sbuf _lb;

  @ffi.Int()
  external int _blksize;

  @fpos_t()
  external int _offset;
}

typedef fpos_t = __darwin_off_t;
typedef __darwin_off_t = __int64_t;
typedef __int64_t = ffi.LongLong;
typedef FILE = __sFILE;
typedef va_list = __darwin_va_list;
typedef __darwin_va_list = __builtin_va_list;
typedef __builtin_va_list = ffi.Pointer<ffi.Char>;
typedef off_t = __darwin_off_t;
typedef ssize_t = __darwin_ssize_t;
typedef __darwin_ssize_t = ffi.Long;
typedef errno_t = ffi.Int;
typedef rsize_t = __darwin_size_t;

class bitset_s extends ffi.Struct {
  external ffi.Pointer<ffi.Uint64> array;

  @ffi.Size()
  external int arraysize;

  @ffi.Size()
  external int capacity;
}

typedef bitset_t = bitset_s;
typedef bitset_iterator = ffi.Pointer<
    ffi.NativeFunction<ffi.Bool Function(ffi.Size, ffi.Pointer<ffi.Void>)>>;

class roaring_bitmap_s extends ffi.Struct {
  external roaring_array_t high_low_container;
}

/// Roaring arrays are array-based key-value pairs having containers as values
/// and 16-bit integer keys. A roaring bitmap  might be implemented as such.
typedef roaring_array_t = roaring_array_s;
typedef roaring_bitmap_t = roaring_bitmap_s;

/// A bit of context usable with `roaring_bitmap_*_bulk()` functions
///
/// Should be initialized with `{0}` (or `memset()` to all zeros).
/// Callers should treat it as an opaque type.
///
/// A context may only be used with a single bitmap
/// (unless re-initialized to zero), and any modification to a bitmap
/// (other than modifications performed with `_bulk()` functions with the context
/// passed) will invalidate any contexts associated with that bitmap.
class roaring_bulk_context_s extends ffi.Struct {
  external ffi.Pointer<ffi.Void> container;

  @ffi.Int()
  external int idx;

  @ffi.Uint16()
  external int key;

  @ffi.Uint8()
  external int typecode;
}

/// A bit of context usable with `roaring_bitmap_*_bulk()` functions
///
/// Should be initialized with `{0}` (or `memset()` to all zeros).
/// Callers should treat it as an opaque type.
///
/// A context may only be used with a single bitmap
/// (unless re-initialized to zero), and any modification to a bitmap
/// (other than modifications performed with `_bulk()` functions with the context
/// passed) will invalidate any contexts associated with that bitmap.
typedef roaring_bulk_context_t = roaring_bulk_context_s;
typedef roaring_iterator = ffi.Pointer<
    ffi.NativeFunction<ffi.Bool Function(ffi.Uint32, ffi.Pointer<ffi.Void>)>>;
typedef roaring_iterator64 = ffi.Pointer<
    ffi.NativeFunction<ffi.Bool Function(ffi.Uint64, ffi.Pointer<ffi.Void>)>>;

/// (For advanced users.)
/// The roaring_statistics_t can be used to collect detailed statistics about
/// the composition of a roaring bitmap.
typedef roaring_statistics_t = roaring_statistics_s;

/// What follows is code use to iterate through values in a roaring bitmap
///
/// roaring_bitmap_t *r =...
/// roaring_uint32_iterator_t i;
/// roaring_create_iterator(r, &i);
/// while(i.has_value) {
/// printf("value = %d\n", i.current_value);
/// roaring_advance_uint32_iterator(&i);
/// }
///
/// Obviously, if you modify the underlying bitmap, the iterator
/// becomes invalid. So don't.
class roaring_uint32_iterator_s extends ffi.Struct {
  external ffi.Pointer<roaring_bitmap_t> parent;

  @ffi.Int32()
  external int container_index;

  @ffi.Int32()
  external int in_container_index;

  @ffi.Int32()
  external int run_index;

  @ffi.Uint32()
  external int current_value;

  @ffi.Bool()
  external bool has_value;

  external ffi.Pointer<ffi.Void> container;

  @ffi.Uint8()
  external int typecode;

  @ffi.Uint32()
  external int highbits;
}

/// What follows is code use to iterate through values in a roaring bitmap
///
/// roaring_bitmap_t *r =...
/// roaring_uint32_iterator_t i;
/// roaring_create_iterator(r, &i);
/// while(i.has_value) {
/// printf("value = %d\n", i.current_value);
/// roaring_advance_uint32_iterator(&i);
/// }
///
/// Obviously, if you modify the underlying bitmap, the iterator
/// becomes invalid. So don't.
typedef roaring_uint32_iterator_t = roaring_uint32_iterator_s;

class roaring_memory_s extends ffi.Struct {
  external roaring_malloc_p malloc;

  external roaring_realloc_p realloc;

  external roaring_calloc_p calloc;

  external roaring_free_p free;

  external roaring_aligned_malloc_p aligned_malloc;

  external roaring_aligned_free_p aligned_free;
}

typedef roaring_malloc_p
    = ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>;
typedef roaring_realloc_p = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size)>>;
typedef roaring_calloc_p = ffi.Pointer<
    ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>;
typedef roaring_free_p
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;
typedef roaring_aligned_malloc_p = ffi.Pointer<
    ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>;
typedef roaring_aligned_free_p
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;
typedef roaring_memory_t = roaring_memory_s;

const int ROARING_VERSION_MAJOR = 1;

const int ROARING_VERSION_MINOR = 2;

const int ROARING_VERSION_REVISION = 0;

const String ROARING_VERSION = '1.2.0';

const int true1 = 1;

const int false1 = 0;

const int __bool_true_false_are_defined = 1;

const int __WORDSIZE = 64;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int USER_ADDR_NULL = 0;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int ROARING_FLAG_COW = 1;

const int ROARING_FLAG_FROZEN = 2;

const int _GNU_SOURCE = 1;

const int __STDC_FORMAT_MACROS = 1;

const int CROARING_VISUAL_STUDIO = 0;

const int CROARING_CLANG_VISUAL_STUDIO = 0;

const int CROARING_REGULAR_VISUAL_STUDIO = 0;

const int _POSIX_C_SOURCE = 200809;

const int _XOPEN_SOURCE = 700;

const int __API_TO_BE_DEPRECATED = 100000;

const int __API_TO_BE_DEPRECATED_MACOS = 100000;

const int __API_TO_BE_DEPRECATED_IOS = 100000;

const int __API_TO_BE_DEPRECATED_TVOS = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYST = 100000;

const int __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __MAC_13_0 = 130000;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __IPHONE_16_0 = 160000;

const int __IPHONE_16_1 = 160100;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __TVOS_16_0 = 160000;

const int __TVOS_16_1 = 160100;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int __WATCHOS_9_0 = 90000;

const int __WATCHOS_9_1 = 90100;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 130000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 130000;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int __DARWIN_NSIG = 32;

const int _ARM_SIGNAL_ = 1;

const int SIGHUP = 1;

const int SIGINT = 2;

const int SIGQUIT = 3;

const int SIGILL = 4;

const int SIGTRAP = 5;

const int SIGABRT = 6;

const int SIGPOLL = 7;

const int SIGFPE = 8;

const int SIGKILL = 9;

const int SIGBUS = 10;

const int SIGSEGV = 11;

const int SIGSYS = 12;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGTERM = 15;

const int SIGURG = 16;

const int SIGSTOP = 17;

const int SIGTSTP = 18;

const int SIGCONT = 19;

const int SIGCHLD = 20;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGXCPU = 24;

const int SIGXFSZ = 25;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGUSR1 = 30;

const int SIGUSR2 = 31;

const int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = 0;

const int SIGEV_NONE = 0;

const int SIGEV_SIGNAL = 1;

const int SIGEV_THREAD = 3;

const int ILL_ILLOPC = 1;

const int ILL_ILLTRP = 2;

const int ILL_PRVOPC = 3;

const int ILL_ILLOPN = 4;

const int ILL_ILLADR = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int FPE_FLTDIV = 1;

const int FPE_FLTOVF = 2;

const int FPE_FLTUND = 3;

const int FPE_FLTRES = 4;

const int FPE_FLTINV = 5;

const int FPE_FLTSUB = 6;

const int FPE_INTDIV = 7;

const int FPE_INTOVF = 8;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int TRAP_BRKPT = 1;

const int TRAP_TRACE = 2;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int SA_ONSTACK = 1;

const int SA_RESTART = 2;

const int SA_RESETHAND = 4;

const int SA_NOCLDSTOP = 8;

const int SA_NODEFER = 16;

const int SA_NOCLDWAIT = 32;

const int SA_SIGINFO = 64;

const int SA_USERSPACE_MASK = 127;

const int SIG_BLOCK = 1;

const int SIG_UNBLOCK = 2;

const int SIG_SETMASK = 3;

const int SI_USER = 65537;

const int SI_QUEUE = 65538;

const int SI_TIMER = 65539;

const int SI_ASYNCIO = 65540;

const int SI_MESGQ = 65541;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 4;

const int MINSIGSTKSZ = 32768;

const int SIGSTKSZ = 131072;

const int PRIO_PROCESS = 0;

const int PRIO_PGRP = 1;

const int PRIO_USER = 2;

const int PRIO_DARWIN_THREAD = 3;

const int PRIO_DARWIN_PROCESS = 4;

const int PRIO_MIN = -20;

const int PRIO_MAX = 20;

const int PRIO_DARWIN_BG = 4096;

const int PRIO_DARWIN_NONUI = 4097;

const int RUSAGE_SELF = 0;

const int RUSAGE_CHILDREN = -1;

const int RUSAGE_INFO_V0 = 0;

const int RUSAGE_INFO_V1 = 1;

const int RUSAGE_INFO_V2 = 2;

const int RUSAGE_INFO_V3 = 3;

const int RUSAGE_INFO_V4 = 4;

const int RUSAGE_INFO_V5 = 5;

const int RUSAGE_INFO_V6 = 6;

const int RUSAGE_INFO_CURRENT = 6;

const int RU_PROC_RUNS_RESLIDE = 1;

const int RLIM_INFINITY = 9223372036854775807;

const int RLIM_SAVED_MAX = 9223372036854775807;

const int RLIM_SAVED_CUR = 9223372036854775807;

const int RLIMIT_CPU = 0;

const int RLIMIT_FSIZE = 1;

const int RLIMIT_DATA = 2;

const int RLIMIT_STACK = 3;

const int RLIMIT_CORE = 4;

const int RLIMIT_AS = 5;

const int RLIMIT_RSS = 5;

const int RLIMIT_MEMLOCK = 6;

const int RLIMIT_NPROC = 7;

const int RLIMIT_NOFILE = 8;

const int RLIM_NLIMITS = 9;

const int _RLIMIT_POSIX_FLAG = 4096;

const int RLIMIT_WAKEUPS_MONITOR = 1;

const int RLIMIT_CPU_USAGE_MONITOR = 2;

const int RLIMIT_THREAD_CPULIMITS = 3;

const int RLIMIT_FOOTPRINT_INTERVAL = 4;

const int WAKEMON_ENABLE = 1;

const int WAKEMON_DISABLE = 2;

const int WAKEMON_GET_PARAMS = 4;

const int WAKEMON_SET_DEFAULTS = 8;

const int WAKEMON_MAKE_FATAL = 16;

const int CPUMON_MAKE_FATAL = 4096;

const int FOOTPRINT_INTERVAL_RESET = 1;

const int IOPOL_TYPE_DISK = 0;

const int IOPOL_TYPE_VFS_ATIME_UPDATES = 2;

const int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3;

const int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4;

const int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5;

const int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6;

const int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7;

const int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8;

const int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = 9;

const int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = 10;

const int IOPOL_SCOPE_PROCESS = 0;

const int IOPOL_SCOPE_THREAD = 1;

const int IOPOL_SCOPE_DARWIN_BG = 2;

const int IOPOL_DEFAULT = 0;

const int IOPOL_IMPORTANT = 1;

const int IOPOL_PASSIVE = 2;

const int IOPOL_THROTTLE = 3;

const int IOPOL_UTILITY = 4;

const int IOPOL_STANDARD = 5;

const int IOPOL_APPLICATION = 5;

const int IOPOL_NORMAL = 1;

const int IOPOL_ATIME_UPDATES_DEFAULT = 0;

const int IOPOL_ATIME_UPDATES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0;

const int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2;

const int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0;

const int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1;

const int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0;

const int IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1;

const int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0;

const int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1;

const int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0;

const int IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = 0;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = 1;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = 0;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int _WSTOPPED = 127;

const int WEXITED = 4;

const int WSTOPPED = 8;

const int WCONTINUED = 16;

const int WNOWAIT = 32;

const int NULL = 0;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int RAND_MAX = 2147483647;

const int CROARING_INLINE_ASM = 1;

const int CROARING_INTRINSICS = 1;

const int CROARING_IS_BIG_ENDIAN = 0;

const int CROARING_ATOMIC_IMPL_NONE = 1;

const int CROARING_ATOMIC_IMPL_CPP = 2;

const int CROARING_ATOMIC_IMPL_C = 3;

const int CROARING_ATOMIC_IMPL_C_WINDOWS = 4;

const int CROARING_ATOMIC_IMPL = 2;

const int ATOMIC_BOOL_LOCK_FREE = 2;

const int ATOMIC_CHAR_LOCK_FREE = 2;

const int ATOMIC_CHAR16_T_LOCK_FREE = 2;

const int ATOMIC_CHAR32_T_LOCK_FREE = 2;

const int ATOMIC_WCHAR_T_LOCK_FREE = 2;

const int ATOMIC_SHORT_LOCK_FREE = 2;

const int ATOMIC_INT_LOCK_FREE = 2;

const int ATOMIC_LONG_LOCK_FREE = 2;

const int ATOMIC_LLONG_LOCK_FREE = 2;

const int ATOMIC_POINTER_LOCK_FREE = 2;

const int RENAME_SECLUDE = 1;

const int RENAME_SWAP = 2;

const int RENAME_EXCL = 4;

const int RENAME_RESERVED1 = 8;

const int RENAME_NOFOLLOW_ANY = 16;

const int __SLBF = 1;

const int __SNBF = 2;

const int __SRD = 4;

const int __SWR = 8;

const int __SRW = 16;

const int __SEOF = 32;

const int __SERR = 64;

const int __SMBF = 128;

const int __SAPP = 256;

const int __SSTR = 512;

const int __SOPT = 1024;

const int __SNPT = 2048;

const int __SOFF = 4096;

const int __SMOD = 8192;

const int __SALC = 16384;

const int __SIGN = 32768;

const int _IOFBF = 0;

const int _IOLBF = 1;

const int _IONBF = 2;

const int BUFSIZ = 1024;

const int EOF = -1;

const int FOPEN_MAX = 20;

const int FILENAME_MAX = 1024;

const String P_tmpdir = '/var/tmp/';

const int L_tmpnam = 1024;

const int TMP_MAX = 308915776;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const int L_ctermid = 1024;
